// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v1.181.2
//   protoc               unknown
// source: message.proto

/* eslint-disable */
import Long from 'long';
import _m0 from 'protobufjs/minimal';
import { Observable } from 'rxjs';
import { map } from 'rxjs/operators';
import { Empty } from './google/protobuf/empty';
import { Timestamp } from './google/protobuf/timestamp';

export const protobufPackage = 'example';

/** Enums for better type safety */
export enum TaskStatus {
  TASK_STATUS_UNSPECIFIED = 0,
  TASK_STATUS_TODO = 1,
  TASK_STATUS_IN_PROGRESS = 2,
  TASK_STATUS_REVIEW = 3,
  TASK_STATUS_DONE = 4,
  TASK_STATUS_CANCELLED = 5,
  UNRECOGNIZED = -1,
}

export function taskStatusFromJSON(object: any): TaskStatus {
  switch (object) {
    case 0:
    case 'TASK_STATUS_UNSPECIFIED':
      return TaskStatus.TASK_STATUS_UNSPECIFIED;
    case 1:
    case 'TASK_STATUS_TODO':
      return TaskStatus.TASK_STATUS_TODO;
    case 2:
    case 'TASK_STATUS_IN_PROGRESS':
      return TaskStatus.TASK_STATUS_IN_PROGRESS;
    case 3:
    case 'TASK_STATUS_REVIEW':
      return TaskStatus.TASK_STATUS_REVIEW;
    case 4:
    case 'TASK_STATUS_DONE':
      return TaskStatus.TASK_STATUS_DONE;
    case 5:
    case 'TASK_STATUS_CANCELLED':
      return TaskStatus.TASK_STATUS_CANCELLED;
    case -1:
    case 'UNRECOGNIZED':
    default:
      return TaskStatus.UNRECOGNIZED;
  }
}

export function taskStatusToJSON(object: TaskStatus): string {
  switch (object) {
    case TaskStatus.TASK_STATUS_UNSPECIFIED:
      return 'TASK_STATUS_UNSPECIFIED';
    case TaskStatus.TASK_STATUS_TODO:
      return 'TASK_STATUS_TODO';
    case TaskStatus.TASK_STATUS_IN_PROGRESS:
      return 'TASK_STATUS_IN_PROGRESS';
    case TaskStatus.TASK_STATUS_REVIEW:
      return 'TASK_STATUS_REVIEW';
    case TaskStatus.TASK_STATUS_DONE:
      return 'TASK_STATUS_DONE';
    case TaskStatus.TASK_STATUS_CANCELLED:
      return 'TASK_STATUS_CANCELLED';
    case TaskStatus.UNRECOGNIZED:
    default:
      return 'UNRECOGNIZED';
  }
}

export enum TaskPriority {
  TASK_PRIORITY_UNSPECIFIED = 0,
  TASK_PRIORITY_LOW = 1,
  TASK_PRIORITY_MEDIUM = 2,
  TASK_PRIORITY_HIGH = 3,
  TASK_PRIORITY_CRITICAL = 4,
  UNRECOGNIZED = -1,
}

export function taskPriorityFromJSON(object: any): TaskPriority {
  switch (object) {
    case 0:
    case 'TASK_PRIORITY_UNSPECIFIED':
      return TaskPriority.TASK_PRIORITY_UNSPECIFIED;
    case 1:
    case 'TASK_PRIORITY_LOW':
      return TaskPriority.TASK_PRIORITY_LOW;
    case 2:
    case 'TASK_PRIORITY_MEDIUM':
      return TaskPriority.TASK_PRIORITY_MEDIUM;
    case 3:
    case 'TASK_PRIORITY_HIGH':
      return TaskPriority.TASK_PRIORITY_HIGH;
    case 4:
    case 'TASK_PRIORITY_CRITICAL':
      return TaskPriority.TASK_PRIORITY_CRITICAL;
    case -1:
    case 'UNRECOGNIZED':
    default:
      return TaskPriority.UNRECOGNIZED;
  }
}

export function taskPriorityToJSON(object: TaskPriority): string {
  switch (object) {
    case TaskPriority.TASK_PRIORITY_UNSPECIFIED:
      return 'TASK_PRIORITY_UNSPECIFIED';
    case TaskPriority.TASK_PRIORITY_LOW:
      return 'TASK_PRIORITY_LOW';
    case TaskPriority.TASK_PRIORITY_MEDIUM:
      return 'TASK_PRIORITY_MEDIUM';
    case TaskPriority.TASK_PRIORITY_HIGH:
      return 'TASK_PRIORITY_HIGH';
    case TaskPriority.TASK_PRIORITY_CRITICAL:
      return 'TASK_PRIORITY_CRITICAL';
    case TaskPriority.UNRECOGNIZED:
    default:
      return 'UNRECOGNIZED';
  }
}

export enum UserRole {
  USER_ROLE_UNSPECIFIED = 0,
  USER_ROLE_VIEWER = 1,
  USER_ROLE_MEMBER = 2,
  USER_ROLE_ADMIN = 3,
  UNRECOGNIZED = -1,
}

export function userRoleFromJSON(object: any): UserRole {
  switch (object) {
    case 0:
    case 'USER_ROLE_UNSPECIFIED':
      return UserRole.USER_ROLE_UNSPECIFIED;
    case 1:
    case 'USER_ROLE_VIEWER':
      return UserRole.USER_ROLE_VIEWER;
    case 2:
    case 'USER_ROLE_MEMBER':
      return UserRole.USER_ROLE_MEMBER;
    case 3:
    case 'USER_ROLE_ADMIN':
      return UserRole.USER_ROLE_ADMIN;
    case -1:
    case 'UNRECOGNIZED':
    default:
      return UserRole.UNRECOGNIZED;
  }
}

export function userRoleToJSON(object: UserRole): string {
  switch (object) {
    case UserRole.USER_ROLE_UNSPECIFIED:
      return 'USER_ROLE_UNSPECIFIED';
    case UserRole.USER_ROLE_VIEWER:
      return 'USER_ROLE_VIEWER';
    case UserRole.USER_ROLE_MEMBER:
      return 'USER_ROLE_MEMBER';
    case UserRole.USER_ROLE_ADMIN:
      return 'USER_ROLE_ADMIN';
    case UserRole.UNRECOGNIZED:
    default:
      return 'UNRECOGNIZED';
  }
}

export enum UserStatus {
  USER_STATUS_UNSPECIFIED = 0,
  USER_STATUS_ACTIVE = 1,
  USER_STATUS_INACTIVE = 2,
  USER_STATUS_SUSPENDED = 3,
  UNRECOGNIZED = -1,
}

export function userStatusFromJSON(object: any): UserStatus {
  switch (object) {
    case 0:
    case 'USER_STATUS_UNSPECIFIED':
      return UserStatus.USER_STATUS_UNSPECIFIED;
    case 1:
    case 'USER_STATUS_ACTIVE':
      return UserStatus.USER_STATUS_ACTIVE;
    case 2:
    case 'USER_STATUS_INACTIVE':
      return UserStatus.USER_STATUS_INACTIVE;
    case 3:
    case 'USER_STATUS_SUSPENDED':
      return UserStatus.USER_STATUS_SUSPENDED;
    case -1:
    case 'UNRECOGNIZED':
    default:
      return UserStatus.UNRECOGNIZED;
  }
}

export function userStatusToJSON(object: UserStatus): string {
  switch (object) {
    case UserStatus.USER_STATUS_UNSPECIFIED:
      return 'USER_STATUS_UNSPECIFIED';
    case UserStatus.USER_STATUS_ACTIVE:
      return 'USER_STATUS_ACTIVE';
    case UserStatus.USER_STATUS_INACTIVE:
      return 'USER_STATUS_INACTIVE';
    case UserStatus.USER_STATUS_SUSPENDED:
      return 'USER_STATUS_SUSPENDED';
    case UserStatus.UNRECOGNIZED:
    default:
      return 'UNRECOGNIZED';
  }
}

export enum TaskSortField {
  TASK_SORT_FIELD_UNSPECIFIED = 0,
  TASK_SORT_FIELD_CREATED_AT = 1,
  TASK_SORT_FIELD_UPDATED_AT = 2,
  TASK_SORT_FIELD_DUE_DATE = 3,
  TASK_SORT_FIELD_PRIORITY = 4,
  TASK_SORT_FIELD_TITLE = 5,
  UNRECOGNIZED = -1,
}

export function taskSortFieldFromJSON(object: any): TaskSortField {
  switch (object) {
    case 0:
    case 'TASK_SORT_FIELD_UNSPECIFIED':
      return TaskSortField.TASK_SORT_FIELD_UNSPECIFIED;
    case 1:
    case 'TASK_SORT_FIELD_CREATED_AT':
      return TaskSortField.TASK_SORT_FIELD_CREATED_AT;
    case 2:
    case 'TASK_SORT_FIELD_UPDATED_AT':
      return TaskSortField.TASK_SORT_FIELD_UPDATED_AT;
    case 3:
    case 'TASK_SORT_FIELD_DUE_DATE':
      return TaskSortField.TASK_SORT_FIELD_DUE_DATE;
    case 4:
    case 'TASK_SORT_FIELD_PRIORITY':
      return TaskSortField.TASK_SORT_FIELD_PRIORITY;
    case 5:
    case 'TASK_SORT_FIELD_TITLE':
      return TaskSortField.TASK_SORT_FIELD_TITLE;
    case -1:
    case 'UNRECOGNIZED':
    default:
      return TaskSortField.UNRECOGNIZED;
  }
}

export function taskSortFieldToJSON(object: TaskSortField): string {
  switch (object) {
    case TaskSortField.TASK_SORT_FIELD_UNSPECIFIED:
      return 'TASK_SORT_FIELD_UNSPECIFIED';
    case TaskSortField.TASK_SORT_FIELD_CREATED_AT:
      return 'TASK_SORT_FIELD_CREATED_AT';
    case TaskSortField.TASK_SORT_FIELD_UPDATED_AT:
      return 'TASK_SORT_FIELD_UPDATED_AT';
    case TaskSortField.TASK_SORT_FIELD_DUE_DATE:
      return 'TASK_SORT_FIELD_DUE_DATE';
    case TaskSortField.TASK_SORT_FIELD_PRIORITY:
      return 'TASK_SORT_FIELD_PRIORITY';
    case TaskSortField.TASK_SORT_FIELD_TITLE:
      return 'TASK_SORT_FIELD_TITLE';
    case TaskSortField.UNRECOGNIZED:
    default:
      return 'UNRECOGNIZED';
  }
}

export enum SortDirection {
  SORT_DIRECTION_UNSPECIFIED = 0,
  SORT_DIRECTION_ASC = 1,
  SORT_DIRECTION_DESC = 2,
  UNRECOGNIZED = -1,
}

export function sortDirectionFromJSON(object: any): SortDirection {
  switch (object) {
    case 0:
    case 'SORT_DIRECTION_UNSPECIFIED':
      return SortDirection.SORT_DIRECTION_UNSPECIFIED;
    case 1:
    case 'SORT_DIRECTION_ASC':
      return SortDirection.SORT_DIRECTION_ASC;
    case 2:
    case 'SORT_DIRECTION_DESC':
      return SortDirection.SORT_DIRECTION_DESC;
    case -1:
    case 'UNRECOGNIZED':
    default:
      return SortDirection.UNRECOGNIZED;
  }
}

export function sortDirectionToJSON(object: SortDirection): string {
  switch (object) {
    case SortDirection.SORT_DIRECTION_UNSPECIFIED:
      return 'SORT_DIRECTION_UNSPECIFIED';
    case SortDirection.SORT_DIRECTION_ASC:
      return 'SORT_DIRECTION_ASC';
    case SortDirection.SORT_DIRECTION_DESC:
      return 'SORT_DIRECTION_DESC';
    case SortDirection.UNRECOGNIZED:
    default:
      return 'UNRECOGNIZED';
  }
}

export enum TaskEventType {
  TASK_EVENT_TYPE_UNSPECIFIED = 0,
  TASK_EVENT_TYPE_CREATED = 1,
  TASK_EVENT_TYPE_UPDATED = 2,
  TASK_EVENT_TYPE_DELETED = 3,
  TASK_EVENT_TYPE_ASSIGNED = 4,
  TASK_EVENT_TYPE_COMPLETED = 5,
  TASK_EVENT_TYPE_COMMENTED = 6,
  UNRECOGNIZED = -1,
}

export function taskEventTypeFromJSON(object: any): TaskEventType {
  switch (object) {
    case 0:
    case 'TASK_EVENT_TYPE_UNSPECIFIED':
      return TaskEventType.TASK_EVENT_TYPE_UNSPECIFIED;
    case 1:
    case 'TASK_EVENT_TYPE_CREATED':
      return TaskEventType.TASK_EVENT_TYPE_CREATED;
    case 2:
    case 'TASK_EVENT_TYPE_UPDATED':
      return TaskEventType.TASK_EVENT_TYPE_UPDATED;
    case 3:
    case 'TASK_EVENT_TYPE_DELETED':
      return TaskEventType.TASK_EVENT_TYPE_DELETED;
    case 4:
    case 'TASK_EVENT_TYPE_ASSIGNED':
      return TaskEventType.TASK_EVENT_TYPE_ASSIGNED;
    case 5:
    case 'TASK_EVENT_TYPE_COMPLETED':
      return TaskEventType.TASK_EVENT_TYPE_COMPLETED;
    case 6:
    case 'TASK_EVENT_TYPE_COMMENTED':
      return TaskEventType.TASK_EVENT_TYPE_COMMENTED;
    case -1:
    case 'UNRECOGNIZED':
    default:
      return TaskEventType.UNRECOGNIZED;
  }
}

export function taskEventTypeToJSON(object: TaskEventType): string {
  switch (object) {
    case TaskEventType.TASK_EVENT_TYPE_UNSPECIFIED:
      return 'TASK_EVENT_TYPE_UNSPECIFIED';
    case TaskEventType.TASK_EVENT_TYPE_CREATED:
      return 'TASK_EVENT_TYPE_CREATED';
    case TaskEventType.TASK_EVENT_TYPE_UPDATED:
      return 'TASK_EVENT_TYPE_UPDATED';
    case TaskEventType.TASK_EVENT_TYPE_DELETED:
      return 'TASK_EVENT_TYPE_DELETED';
    case TaskEventType.TASK_EVENT_TYPE_ASSIGNED:
      return 'TASK_EVENT_TYPE_ASSIGNED';
    case TaskEventType.TASK_EVENT_TYPE_COMPLETED:
      return 'TASK_EVENT_TYPE_COMPLETED';
    case TaskEventType.TASK_EVENT_TYPE_COMMENTED:
      return 'TASK_EVENT_TYPE_COMMENTED';
    case TaskEventType.UNRECOGNIZED:
    default:
      return 'UNRECOGNIZED';
  }
}

/** Core domain entities */
export interface Task {
  id: string;
  title: string;
  description: string;
  status: TaskStatus;
  priority: TaskPriority;
  tags: string[];
  assignedTo: string;
  createdAt: Date | undefined;
  updatedAt: Date | undefined;
  dueDate: Date | undefined;
  metrics: TaskMetrics | undefined;
  comments: TaskComment[];
  attachments: TaskAttachment[];
}

export interface TaskComment {
  id: string;
  taskId: string;
  authorId: string;
  content: string;
  createdAt: Date | undefined;
}

export interface TaskMetrics {
  estimatedHours: number;
  actualHours: number;
  completionPercentage: number;
}

export interface TaskAttachment {
  id: string;
  filename: string;
  contentType: string;
  fileSize: number;
  uploadedAt: Date | undefined;
  uploadedBy: string;
  url: string;
}

export interface User {
  id: string;
  username: string;
  email: string;
  fullName: string;
  role: UserRole;
  permissions: string[];
  lastLogin: Date | undefined;
  isActive: boolean;
  status: UserStatus;
  createdAt: Date | undefined;
  updatedAt: Date | undefined;
  preferences: UserPreferences | undefined;
  profile: UserProfile | undefined;
}

export interface UserPreferences {
  theme: string;
  language: string;
  timezone: string;
  notificationsEnabled: boolean;
  emailNotifications: boolean;
}

export interface UserProfile {
  avatarUrl: string;
  bio: string;
  department: string;
  phone: string;
  location: string;
}

/** Standard CRUD operations */
export interface CreateTaskRequest {
  title: string;
  description: string;
  priority: TaskPriority;
  tags: string[];
  assignedTo: string;
  dueDate: Date | undefined;
}

export interface CreateTaskResponse {
  task: Task | undefined;
  success: boolean;
  message: string;
}

export interface GetTaskRequest {
  id: string;
  includeComments: boolean;
}

export interface GetTaskResponse {
  task: Task | undefined;
  found: boolean;
}

export interface UpdateTaskRequest {
  id: string;
  task: Task | undefined;
  /** Field mask for partial updates */
  updateMask: string[];
}

export interface UpdateTaskResponse {
  task: Task | undefined;
  success: boolean;
  message: string;
}

export interface DeleteTaskRequest {
  id: string;
  /** Hard delete vs soft delete */
  force: boolean;
}

export interface DeleteTaskResponse {
  success: boolean;
  message: string;
}

/** List/Query operations with pagination and filtering */
export interface ListTasksRequest {
  pageSize: number;
  pageToken: string;
  filter: TaskFilter | undefined;
  sort: TaskSort | undefined;
}

export interface ListTasksResponse {
  tasks: Task[];
  nextPageToken: string;
  totalCount: number;
}

export interface TaskFilter {
  status: TaskStatus[];
  priority: TaskPriority[];
  tags: string[];
  assignedTo: string;
  dueBefore: Date | undefined;
  dueAfter: Date | undefined;
  searchQuery: string;
}

export interface TaskSort {
  field: TaskSortField;
  direction: SortDirection;
}

/** Bulk operations */
export interface BulkUpdateTasksRequest {
  taskIds: string[];
  status: TaskStatus;
  assignedTo: string;
  tagsToAdd: string[];
  tagsToRemove: string[];
}

export interface BulkUpdateTasksResponse {
  updatedCount: number;
  failedIds: string[];
  message: string;
}

/** Search operations */
export interface SearchTasksRequest {
  query: string;
  filters: TaskFilter | undefined;
  pageSize: number;
  pageToken: string;
}

export interface SearchTasksResponse {
  tasks: Task[];
  totalCount: number;
  searchTimeMs: number;
}

/** Real-time streaming messages */
export interface TaskEvent {
  eventId: string;
  eventType: TaskEventType;
  task: Task | undefined;
  userId: string;
  timestamp: Date | undefined;
  metadata: { [key: string]: string };
}

export interface TaskEvent_MetadataEntry {
  key: string;
  value: string;
}

export interface StreamTaskEventsRequest {
  /** Empty = all tasks */
  taskIds: string[];
  /** Empty = all events */
  eventTypes: TaskEventType[];
  /** Filter by user */
  userId: string;
}

/** Analytics and reporting */
export interface GetTaskAnalyticsRequest {
  startDate: Date | undefined;
  endDate: Date | undefined;
  userIds: string[];
  /** "status", "user", "priority", "day", "week" */
  groupBy: string;
}

export interface GetTaskAnalyticsResponse {
  analytics: TaskAnalytics | undefined;
  generatedAt: Date | undefined;
}

export interface TaskAnalytics {
  totalTasks: number;
  completedTasks: number;
  inProgressTasks: number;
  todoTasks: number;
  completionRate: number;
  averageCompletionTimeHours: number;
  overdueTasks: number;
  tasksByPriority: { [key: number]: number };
  tasksCreatedThisWeek: number;
  tasksCompletedThisWeek: number;
}

export interface TaskAnalytics_TasksByPriorityEntry {
  key: number;
  value: number;
}

export interface TaskMetricPoint {
  label: string;
  count: number;
  value: number;
  timestamp: Date | undefined;
}

export interface TaskSummary {
  totalTasks: number;
  completedTasks: number;
  completionRate: number;
  averageCompletionTimeHours: number;
  overdueTasks: number;
}

/** File upload/attachment support */
export interface UploadTaskAttachmentRequest {
  taskId: string;
  chunk: Uint8Array;
  filename: string;
  contentType: string;
  totalSize: number;
  chunkIndex: number;
  isFinalChunk: boolean;
}

export interface UploadTaskAttachmentResponse {
  attachmentId: string;
  filename: string;
  fileSize: number;
  success: boolean;
  message: string;
}

export interface CreateUserRequest {
  username: string;
  email: string;
  password: string;
  fullName: string;
  role: UserRole;
}

export interface CreateUserResponse {
  user: User | undefined;
  success: boolean;
  message: string;
}

export interface GetUserRequest {
  id: string;
}

export interface GetUserResponse {
  user: User | undefined;
  found: boolean;
}

export interface ListUsersRequest {
  pageSize: number;
  pageToken: string;
  role: UserRole;
  activeOnly: boolean;
}

export interface ListUsersResponse {
  users: User[];
  nextPageToken: string;
  totalCount: number;
}

export interface UpdateUserRequest {
  id: string;
  user: User | undefined;
}

export interface UpdateUserResponse {
  user: User | undefined;
  success: boolean;
  message: string;
}

export interface DeleteUserRequest {
  id: string;
}

export interface DeleteUserResponse {
  success: boolean;
  message: string;
}

export interface AuthenticateUserRequest {
  email: string;
  password: string;
}

export interface AuthenticateUserResponse {
  user: User | undefined;
  token: string;
  success: boolean;
  message: string;
  expiresAt: Date | undefined;
}

export interface GetUserTasksRequest {
  userId: string;
  pageSize: number;
  pageToken: string;
}

export interface GetUserTasksResponse {
  tasks: Task[];
  nextPageToken: string;
  totalCount: number;
}

export interface UpdateUserPreferencesRequest {
  userId: string;
  preferences: UserPreferences | undefined;
}

export interface UpdateUserPreferencesResponse {
  preferences: UserPreferences | undefined;
  success: boolean;
  message: string;
}

/** Legacy login messages (keeping for backward compatibility) */
export interface LoginRequest {
  username: string;
  password: string;
}

export interface LoginResponse {
  accessToken: string;
  refreshToken: string;
  user: User | undefined;
  expiresAt: Date | undefined;
}

export interface RefreshTokenRequest {
  refreshToken: string;
}

export interface RefreshTokenResponse {
  accessToken: string;
  expiresAt: Date | undefined;
}

export interface LogoutRequest {
  accessToken: string;
}

export interface HealthResponse {
  healthy: boolean;
  version: string;
  timestamp: Date | undefined;
}

function createBaseTask(): Task {
  return {
    id: '',
    title: '',
    description: '',
    status: 0,
    priority: 0,
    tags: [],
    assignedTo: '',
    createdAt: undefined,
    updatedAt: undefined,
    dueDate: undefined,
    metrics: undefined,
    comments: [],
    attachments: [],
  };
}

export const Task = {
  encode(message: Task, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.id !== '') {
      writer.uint32(10).string(message.id);
    }
    if (message.title !== '') {
      writer.uint32(18).string(message.title);
    }
    if (message.description !== '') {
      writer.uint32(26).string(message.description);
    }
    if (message.status !== 0) {
      writer.uint32(32).int32(message.status);
    }
    if (message.priority !== 0) {
      writer.uint32(40).int32(message.priority);
    }
    for (const v of message.tags) {
      writer.uint32(50).string(v!);
    }
    if (message.assignedTo !== '') {
      writer.uint32(58).string(message.assignedTo);
    }
    if (message.createdAt !== undefined) {
      Timestamp.encode(toTimestamp(message.createdAt), writer.uint32(66).fork()).ldelim();
    }
    if (message.updatedAt !== undefined) {
      Timestamp.encode(toTimestamp(message.updatedAt), writer.uint32(74).fork()).ldelim();
    }
    if (message.dueDate !== undefined) {
      Timestamp.encode(toTimestamp(message.dueDate), writer.uint32(82).fork()).ldelim();
    }
    if (message.metrics !== undefined) {
      TaskMetrics.encode(message.metrics, writer.uint32(90).fork()).ldelim();
    }
    for (const v of message.comments) {
      TaskComment.encode(v!, writer.uint32(98).fork()).ldelim();
    }
    for (const v of message.attachments) {
      TaskAttachment.encode(v!, writer.uint32(106).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): Task {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTask();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.title = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.description = reader.string();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.status = reader.int32() as any;
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.priority = reader.int32() as any;
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.tags.push(reader.string());
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.assignedTo = reader.string();
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.createdAt = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.updatedAt = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }

          message.dueDate = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 11:
          if (tag !== 90) {
            break;
          }

          message.metrics = TaskMetrics.decode(reader, reader.uint32());
          continue;
        case 12:
          if (tag !== 98) {
            break;
          }

          message.comments.push(TaskComment.decode(reader, reader.uint32()));
          continue;
        case 13:
          if (tag !== 106) {
            break;
          }

          message.attachments.push(TaskAttachment.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Task {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : '',
      title: isSet(object.title) ? globalThis.String(object.title) : '',
      description: isSet(object.description) ? globalThis.String(object.description) : '',
      status: isSet(object.status) ? taskStatusFromJSON(object.status) : 0,
      priority: isSet(object.priority) ? taskPriorityFromJSON(object.priority) : 0,
      tags: globalThis.Array.isArray(object?.tags)
        ? object.tags.map((e: any) => globalThis.String(e))
        : [],
      assignedTo: isSet(object.assignedTo) ? globalThis.String(object.assignedTo) : '',
      createdAt: isSet(object.createdAt) ? fromJsonTimestamp(object.createdAt) : undefined,
      updatedAt: isSet(object.updatedAt) ? fromJsonTimestamp(object.updatedAt) : undefined,
      dueDate: isSet(object.dueDate) ? fromJsonTimestamp(object.dueDate) : undefined,
      metrics: isSet(object.metrics) ? TaskMetrics.fromJSON(object.metrics) : undefined,
      comments: globalThis.Array.isArray(object?.comments)
        ? object.comments.map((e: any) => TaskComment.fromJSON(e))
        : [],
      attachments: globalThis.Array.isArray(object?.attachments)
        ? object.attachments.map((e: any) => TaskAttachment.fromJSON(e))
        : [],
    };
  },

  toJSON(message: Task): unknown {
    const obj: any = {};
    if (message.id !== '') {
      obj.id = message.id;
    }
    if (message.title !== '') {
      obj.title = message.title;
    }
    if (message.description !== '') {
      obj.description = message.description;
    }
    if (message.status !== 0) {
      obj.status = taskStatusToJSON(message.status);
    }
    if (message.priority !== 0) {
      obj.priority = taskPriorityToJSON(message.priority);
    }
    if (message.tags?.length) {
      obj.tags = message.tags;
    }
    if (message.assignedTo !== '') {
      obj.assignedTo = message.assignedTo;
    }
    if (message.createdAt !== undefined) {
      obj.createdAt = message.createdAt.toISOString();
    }
    if (message.updatedAt !== undefined) {
      obj.updatedAt = message.updatedAt.toISOString();
    }
    if (message.dueDate !== undefined) {
      obj.dueDate = message.dueDate.toISOString();
    }
    if (message.metrics !== undefined) {
      obj.metrics = TaskMetrics.toJSON(message.metrics);
    }
    if (message.comments?.length) {
      obj.comments = message.comments.map((e) => TaskComment.toJSON(e));
    }
    if (message.attachments?.length) {
      obj.attachments = message.attachments.map((e) => TaskAttachment.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Task>, I>>(base?: I): Task {
    return Task.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Task>, I>>(object: I): Task {
    const message = createBaseTask();
    message.id = object.id ?? '';
    message.title = object.title ?? '';
    message.description = object.description ?? '';
    message.status = object.status ?? 0;
    message.priority = object.priority ?? 0;
    message.tags = object.tags?.map((e) => e) || [];
    message.assignedTo = object.assignedTo ?? '';
    message.createdAt = object.createdAt ?? undefined;
    message.updatedAt = object.updatedAt ?? undefined;
    message.dueDate = object.dueDate ?? undefined;
    message.metrics =
      object.metrics !== undefined && object.metrics !== null
        ? TaskMetrics.fromPartial(object.metrics)
        : undefined;
    message.comments = object.comments?.map((e) => TaskComment.fromPartial(e)) || [];
    message.attachments = object.attachments?.map((e) => TaskAttachment.fromPartial(e)) || [];
    return message;
  },
};

function createBaseTaskComment(): TaskComment {
  return { id: '', taskId: '', authorId: '', content: '', createdAt: undefined };
}

export const TaskComment = {
  encode(message: TaskComment, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.id !== '') {
      writer.uint32(10).string(message.id);
    }
    if (message.taskId !== '') {
      writer.uint32(18).string(message.taskId);
    }
    if (message.authorId !== '') {
      writer.uint32(26).string(message.authorId);
    }
    if (message.content !== '') {
      writer.uint32(34).string(message.content);
    }
    if (message.createdAt !== undefined) {
      Timestamp.encode(toTimestamp(message.createdAt), writer.uint32(42).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): TaskComment {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTaskComment();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.taskId = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.authorId = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.content = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.createdAt = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TaskComment {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : '',
      taskId: isSet(object.taskId) ? globalThis.String(object.taskId) : '',
      authorId: isSet(object.authorId) ? globalThis.String(object.authorId) : '',
      content: isSet(object.content) ? globalThis.String(object.content) : '',
      createdAt: isSet(object.createdAt) ? fromJsonTimestamp(object.createdAt) : undefined,
    };
  },

  toJSON(message: TaskComment): unknown {
    const obj: any = {};
    if (message.id !== '') {
      obj.id = message.id;
    }
    if (message.taskId !== '') {
      obj.taskId = message.taskId;
    }
    if (message.authorId !== '') {
      obj.authorId = message.authorId;
    }
    if (message.content !== '') {
      obj.content = message.content;
    }
    if (message.createdAt !== undefined) {
      obj.createdAt = message.createdAt.toISOString();
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<TaskComment>, I>>(base?: I): TaskComment {
    return TaskComment.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<TaskComment>, I>>(object: I): TaskComment {
    const message = createBaseTaskComment();
    message.id = object.id ?? '';
    message.taskId = object.taskId ?? '';
    message.authorId = object.authorId ?? '';
    message.content = object.content ?? '';
    message.createdAt = object.createdAt ?? undefined;
    return message;
  },
};

function createBaseTaskMetrics(): TaskMetrics {
  return { estimatedHours: 0, actualHours: 0, completionPercentage: 0 };
}

export const TaskMetrics = {
  encode(message: TaskMetrics, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.estimatedHours !== 0) {
      writer.uint32(8).int32(message.estimatedHours);
    }
    if (message.actualHours !== 0) {
      writer.uint32(16).int32(message.actualHours);
    }
    if (message.completionPercentage !== 0) {
      writer.uint32(25).double(message.completionPercentage);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): TaskMetrics {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTaskMetrics();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.estimatedHours = reader.int32();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.actualHours = reader.int32();
          continue;
        case 3:
          if (tag !== 25) {
            break;
          }

          message.completionPercentage = reader.double();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TaskMetrics {
    return {
      estimatedHours: isSet(object.estimatedHours) ? globalThis.Number(object.estimatedHours) : 0,
      actualHours: isSet(object.actualHours) ? globalThis.Number(object.actualHours) : 0,
      completionPercentage: isSet(object.completionPercentage)
        ? globalThis.Number(object.completionPercentage)
        : 0,
    };
  },

  toJSON(message: TaskMetrics): unknown {
    const obj: any = {};
    if (message.estimatedHours !== 0) {
      obj.estimatedHours = Math.round(message.estimatedHours);
    }
    if (message.actualHours !== 0) {
      obj.actualHours = Math.round(message.actualHours);
    }
    if (message.completionPercentage !== 0) {
      obj.completionPercentage = message.completionPercentage;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<TaskMetrics>, I>>(base?: I): TaskMetrics {
    return TaskMetrics.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<TaskMetrics>, I>>(object: I): TaskMetrics {
    const message = createBaseTaskMetrics();
    message.estimatedHours = object.estimatedHours ?? 0;
    message.actualHours = object.actualHours ?? 0;
    message.completionPercentage = object.completionPercentage ?? 0;
    return message;
  },
};

function createBaseTaskAttachment(): TaskAttachment {
  return {
    id: '',
    filename: '',
    contentType: '',
    fileSize: 0,
    uploadedAt: undefined,
    uploadedBy: '',
    url: '',
  };
}

export const TaskAttachment = {
  encode(message: TaskAttachment, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.id !== '') {
      writer.uint32(10).string(message.id);
    }
    if (message.filename !== '') {
      writer.uint32(18).string(message.filename);
    }
    if (message.contentType !== '') {
      writer.uint32(26).string(message.contentType);
    }
    if (message.fileSize !== 0) {
      writer.uint32(32).uint64(message.fileSize);
    }
    if (message.uploadedAt !== undefined) {
      Timestamp.encode(toTimestamp(message.uploadedAt), writer.uint32(42).fork()).ldelim();
    }
    if (message.uploadedBy !== '') {
      writer.uint32(50).string(message.uploadedBy);
    }
    if (message.url !== '') {
      writer.uint32(58).string(message.url);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): TaskAttachment {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTaskAttachment();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.filename = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.contentType = reader.string();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.fileSize = longToNumber(reader.uint64() as Long);
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.uploadedAt = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.uploadedBy = reader.string();
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.url = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TaskAttachment {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : '',
      filename: isSet(object.filename) ? globalThis.String(object.filename) : '',
      contentType: isSet(object.contentType) ? globalThis.String(object.contentType) : '',
      fileSize: isSet(object.fileSize) ? globalThis.Number(object.fileSize) : 0,
      uploadedAt: isSet(object.uploadedAt) ? fromJsonTimestamp(object.uploadedAt) : undefined,
      uploadedBy: isSet(object.uploadedBy) ? globalThis.String(object.uploadedBy) : '',
      url: isSet(object.url) ? globalThis.String(object.url) : '',
    };
  },

  toJSON(message: TaskAttachment): unknown {
    const obj: any = {};
    if (message.id !== '') {
      obj.id = message.id;
    }
    if (message.filename !== '') {
      obj.filename = message.filename;
    }
    if (message.contentType !== '') {
      obj.contentType = message.contentType;
    }
    if (message.fileSize !== 0) {
      obj.fileSize = Math.round(message.fileSize);
    }
    if (message.uploadedAt !== undefined) {
      obj.uploadedAt = message.uploadedAt.toISOString();
    }
    if (message.uploadedBy !== '') {
      obj.uploadedBy = message.uploadedBy;
    }
    if (message.url !== '') {
      obj.url = message.url;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<TaskAttachment>, I>>(base?: I): TaskAttachment {
    return TaskAttachment.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<TaskAttachment>, I>>(object: I): TaskAttachment {
    const message = createBaseTaskAttachment();
    message.id = object.id ?? '';
    message.filename = object.filename ?? '';
    message.contentType = object.contentType ?? '';
    message.fileSize = object.fileSize ?? 0;
    message.uploadedAt = object.uploadedAt ?? undefined;
    message.uploadedBy = object.uploadedBy ?? '';
    message.url = object.url ?? '';
    return message;
  },
};

function createBaseUser(): User {
  return {
    id: '',
    username: '',
    email: '',
    fullName: '',
    role: 0,
    permissions: [],
    lastLogin: undefined,
    isActive: false,
    status: 0,
    createdAt: undefined,
    updatedAt: undefined,
    preferences: undefined,
    profile: undefined,
  };
}

export const User = {
  encode(message: User, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.id !== '') {
      writer.uint32(10).string(message.id);
    }
    if (message.username !== '') {
      writer.uint32(18).string(message.username);
    }
    if (message.email !== '') {
      writer.uint32(26).string(message.email);
    }
    if (message.fullName !== '') {
      writer.uint32(34).string(message.fullName);
    }
    if (message.role !== 0) {
      writer.uint32(40).int32(message.role);
    }
    for (const v of message.permissions) {
      writer.uint32(50).string(v!);
    }
    if (message.lastLogin !== undefined) {
      Timestamp.encode(toTimestamp(message.lastLogin), writer.uint32(58).fork()).ldelim();
    }
    if (message.isActive !== false) {
      writer.uint32(64).bool(message.isActive);
    }
    if (message.status !== 0) {
      writer.uint32(72).int32(message.status);
    }
    if (message.createdAt !== undefined) {
      Timestamp.encode(toTimestamp(message.createdAt), writer.uint32(82).fork()).ldelim();
    }
    if (message.updatedAt !== undefined) {
      Timestamp.encode(toTimestamp(message.updatedAt), writer.uint32(90).fork()).ldelim();
    }
    if (message.preferences !== undefined) {
      UserPreferences.encode(message.preferences, writer.uint32(98).fork()).ldelim();
    }
    if (message.profile !== undefined) {
      UserProfile.encode(message.profile, writer.uint32(106).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): User {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUser();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.username = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.email = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.fullName = reader.string();
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.role = reader.int32() as any;
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.permissions.push(reader.string());
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.lastLogin = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 8:
          if (tag !== 64) {
            break;
          }

          message.isActive = reader.bool();
          continue;
        case 9:
          if (tag !== 72) {
            break;
          }

          message.status = reader.int32() as any;
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }

          message.createdAt = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 11:
          if (tag !== 90) {
            break;
          }

          message.updatedAt = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 12:
          if (tag !== 98) {
            break;
          }

          message.preferences = UserPreferences.decode(reader, reader.uint32());
          continue;
        case 13:
          if (tag !== 106) {
            break;
          }

          message.profile = UserProfile.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): User {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : '',
      username: isSet(object.username) ? globalThis.String(object.username) : '',
      email: isSet(object.email) ? globalThis.String(object.email) : '',
      fullName: isSet(object.fullName) ? globalThis.String(object.fullName) : '',
      role: isSet(object.role) ? userRoleFromJSON(object.role) : 0,
      permissions: globalThis.Array.isArray(object?.permissions)
        ? object.permissions.map((e: any) => globalThis.String(e))
        : [],
      lastLogin: isSet(object.lastLogin) ? fromJsonTimestamp(object.lastLogin) : undefined,
      isActive: isSet(object.isActive) ? globalThis.Boolean(object.isActive) : false,
      status: isSet(object.status) ? userStatusFromJSON(object.status) : 0,
      createdAt: isSet(object.createdAt) ? fromJsonTimestamp(object.createdAt) : undefined,
      updatedAt: isSet(object.updatedAt) ? fromJsonTimestamp(object.updatedAt) : undefined,
      preferences: isSet(object.preferences)
        ? UserPreferences.fromJSON(object.preferences)
        : undefined,
      profile: isSet(object.profile) ? UserProfile.fromJSON(object.profile) : undefined,
    };
  },

  toJSON(message: User): unknown {
    const obj: any = {};
    if (message.id !== '') {
      obj.id = message.id;
    }
    if (message.username !== '') {
      obj.username = message.username;
    }
    if (message.email !== '') {
      obj.email = message.email;
    }
    if (message.fullName !== '') {
      obj.fullName = message.fullName;
    }
    if (message.role !== 0) {
      obj.role = userRoleToJSON(message.role);
    }
    if (message.permissions?.length) {
      obj.permissions = message.permissions;
    }
    if (message.lastLogin !== undefined) {
      obj.lastLogin = message.lastLogin.toISOString();
    }
    if (message.isActive !== false) {
      obj.isActive = message.isActive;
    }
    if (message.status !== 0) {
      obj.status = userStatusToJSON(message.status);
    }
    if (message.createdAt !== undefined) {
      obj.createdAt = message.createdAt.toISOString();
    }
    if (message.updatedAt !== undefined) {
      obj.updatedAt = message.updatedAt.toISOString();
    }
    if (message.preferences !== undefined) {
      obj.preferences = UserPreferences.toJSON(message.preferences);
    }
    if (message.profile !== undefined) {
      obj.profile = UserProfile.toJSON(message.profile);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<User>, I>>(base?: I): User {
    return User.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<User>, I>>(object: I): User {
    const message = createBaseUser();
    message.id = object.id ?? '';
    message.username = object.username ?? '';
    message.email = object.email ?? '';
    message.fullName = object.fullName ?? '';
    message.role = object.role ?? 0;
    message.permissions = object.permissions?.map((e) => e) || [];
    message.lastLogin = object.lastLogin ?? undefined;
    message.isActive = object.isActive ?? false;
    message.status = object.status ?? 0;
    message.createdAt = object.createdAt ?? undefined;
    message.updatedAt = object.updatedAt ?? undefined;
    message.preferences =
      object.preferences !== undefined && object.preferences !== null
        ? UserPreferences.fromPartial(object.preferences)
        : undefined;
    message.profile =
      object.profile !== undefined && object.profile !== null
        ? UserProfile.fromPartial(object.profile)
        : undefined;
    return message;
  },
};

function createBaseUserPreferences(): UserPreferences {
  return {
    theme: '',
    language: '',
    timezone: '',
    notificationsEnabled: false,
    emailNotifications: false,
  };
}

export const UserPreferences = {
  encode(message: UserPreferences, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.theme !== '') {
      writer.uint32(10).string(message.theme);
    }
    if (message.language !== '') {
      writer.uint32(18).string(message.language);
    }
    if (message.timezone !== '') {
      writer.uint32(26).string(message.timezone);
    }
    if (message.notificationsEnabled !== false) {
      writer.uint32(32).bool(message.notificationsEnabled);
    }
    if (message.emailNotifications !== false) {
      writer.uint32(40).bool(message.emailNotifications);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): UserPreferences {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUserPreferences();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.theme = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.language = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.timezone = reader.string();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.notificationsEnabled = reader.bool();
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.emailNotifications = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UserPreferences {
    return {
      theme: isSet(object.theme) ? globalThis.String(object.theme) : '',
      language: isSet(object.language) ? globalThis.String(object.language) : '',
      timezone: isSet(object.timezone) ? globalThis.String(object.timezone) : '',
      notificationsEnabled: isSet(object.notificationsEnabled)
        ? globalThis.Boolean(object.notificationsEnabled)
        : false,
      emailNotifications: isSet(object.emailNotifications)
        ? globalThis.Boolean(object.emailNotifications)
        : false,
    };
  },

  toJSON(message: UserPreferences): unknown {
    const obj: any = {};
    if (message.theme !== '') {
      obj.theme = message.theme;
    }
    if (message.language !== '') {
      obj.language = message.language;
    }
    if (message.timezone !== '') {
      obj.timezone = message.timezone;
    }
    if (message.notificationsEnabled !== false) {
      obj.notificationsEnabled = message.notificationsEnabled;
    }
    if (message.emailNotifications !== false) {
      obj.emailNotifications = message.emailNotifications;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<UserPreferences>, I>>(base?: I): UserPreferences {
    return UserPreferences.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<UserPreferences>, I>>(object: I): UserPreferences {
    const message = createBaseUserPreferences();
    message.theme = object.theme ?? '';
    message.language = object.language ?? '';
    message.timezone = object.timezone ?? '';
    message.notificationsEnabled = object.notificationsEnabled ?? false;
    message.emailNotifications = object.emailNotifications ?? false;
    return message;
  },
};

function createBaseUserProfile(): UserProfile {
  return { avatarUrl: '', bio: '', department: '', phone: '', location: '' };
}

export const UserProfile = {
  encode(message: UserProfile, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.avatarUrl !== '') {
      writer.uint32(10).string(message.avatarUrl);
    }
    if (message.bio !== '') {
      writer.uint32(18).string(message.bio);
    }
    if (message.department !== '') {
      writer.uint32(26).string(message.department);
    }
    if (message.phone !== '') {
      writer.uint32(34).string(message.phone);
    }
    if (message.location !== '') {
      writer.uint32(42).string(message.location);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): UserProfile {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUserProfile();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.avatarUrl = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.bio = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.department = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.phone = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.location = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UserProfile {
    return {
      avatarUrl: isSet(object.avatarUrl) ? globalThis.String(object.avatarUrl) : '',
      bio: isSet(object.bio) ? globalThis.String(object.bio) : '',
      department: isSet(object.department) ? globalThis.String(object.department) : '',
      phone: isSet(object.phone) ? globalThis.String(object.phone) : '',
      location: isSet(object.location) ? globalThis.String(object.location) : '',
    };
  },

  toJSON(message: UserProfile): unknown {
    const obj: any = {};
    if (message.avatarUrl !== '') {
      obj.avatarUrl = message.avatarUrl;
    }
    if (message.bio !== '') {
      obj.bio = message.bio;
    }
    if (message.department !== '') {
      obj.department = message.department;
    }
    if (message.phone !== '') {
      obj.phone = message.phone;
    }
    if (message.location !== '') {
      obj.location = message.location;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<UserProfile>, I>>(base?: I): UserProfile {
    return UserProfile.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<UserProfile>, I>>(object: I): UserProfile {
    const message = createBaseUserProfile();
    message.avatarUrl = object.avatarUrl ?? '';
    message.bio = object.bio ?? '';
    message.department = object.department ?? '';
    message.phone = object.phone ?? '';
    message.location = object.location ?? '';
    return message;
  },
};

function createBaseCreateTaskRequest(): CreateTaskRequest {
  return { title: '', description: '', priority: 0, tags: [], assignedTo: '', dueDate: undefined };
}

export const CreateTaskRequest = {
  encode(message: CreateTaskRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.title !== '') {
      writer.uint32(10).string(message.title);
    }
    if (message.description !== '') {
      writer.uint32(18).string(message.description);
    }
    if (message.priority !== 0) {
      writer.uint32(24).int32(message.priority);
    }
    for (const v of message.tags) {
      writer.uint32(34).string(v!);
    }
    if (message.assignedTo !== '') {
      writer.uint32(42).string(message.assignedTo);
    }
    if (message.dueDate !== undefined) {
      Timestamp.encode(toTimestamp(message.dueDate), writer.uint32(50).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CreateTaskRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateTaskRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.title = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.description = reader.string();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.priority = reader.int32() as any;
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.tags.push(reader.string());
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.assignedTo = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.dueDate = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateTaskRequest {
    return {
      title: isSet(object.title) ? globalThis.String(object.title) : '',
      description: isSet(object.description) ? globalThis.String(object.description) : '',
      priority: isSet(object.priority) ? taskPriorityFromJSON(object.priority) : 0,
      tags: globalThis.Array.isArray(object?.tags)
        ? object.tags.map((e: any) => globalThis.String(e))
        : [],
      assignedTo: isSet(object.assignedTo) ? globalThis.String(object.assignedTo) : '',
      dueDate: isSet(object.dueDate) ? fromJsonTimestamp(object.dueDate) : undefined,
    };
  },

  toJSON(message: CreateTaskRequest): unknown {
    const obj: any = {};
    if (message.title !== '') {
      obj.title = message.title;
    }
    if (message.description !== '') {
      obj.description = message.description;
    }
    if (message.priority !== 0) {
      obj.priority = taskPriorityToJSON(message.priority);
    }
    if (message.tags?.length) {
      obj.tags = message.tags;
    }
    if (message.assignedTo !== '') {
      obj.assignedTo = message.assignedTo;
    }
    if (message.dueDate !== undefined) {
      obj.dueDate = message.dueDate.toISOString();
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CreateTaskRequest>, I>>(base?: I): CreateTaskRequest {
    return CreateTaskRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CreateTaskRequest>, I>>(object: I): CreateTaskRequest {
    const message = createBaseCreateTaskRequest();
    message.title = object.title ?? '';
    message.description = object.description ?? '';
    message.priority = object.priority ?? 0;
    message.tags = object.tags?.map((e) => e) || [];
    message.assignedTo = object.assignedTo ?? '';
    message.dueDate = object.dueDate ?? undefined;
    return message;
  },
};

function createBaseCreateTaskResponse(): CreateTaskResponse {
  return { task: undefined, success: false, message: '' };
}

export const CreateTaskResponse = {
  encode(message: CreateTaskResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.task !== undefined) {
      Task.encode(message.task, writer.uint32(10).fork()).ldelim();
    }
    if (message.success !== false) {
      writer.uint32(16).bool(message.success);
    }
    if (message.message !== '') {
      writer.uint32(26).string(message.message);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CreateTaskResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateTaskResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.task = Task.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.success = reader.bool();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.message = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateTaskResponse {
    return {
      task: isSet(object.task) ? Task.fromJSON(object.task) : undefined,
      success: isSet(object.success) ? globalThis.Boolean(object.success) : false,
      message: isSet(object.message) ? globalThis.String(object.message) : '',
    };
  },

  toJSON(message: CreateTaskResponse): unknown {
    const obj: any = {};
    if (message.task !== undefined) {
      obj.task = Task.toJSON(message.task);
    }
    if (message.success !== false) {
      obj.success = message.success;
    }
    if (message.message !== '') {
      obj.message = message.message;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CreateTaskResponse>, I>>(base?: I): CreateTaskResponse {
    return CreateTaskResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CreateTaskResponse>, I>>(object: I): CreateTaskResponse {
    const message = createBaseCreateTaskResponse();
    message.task =
      object.task !== undefined && object.task !== null ? Task.fromPartial(object.task) : undefined;
    message.success = object.success ?? false;
    message.message = object.message ?? '';
    return message;
  },
};

function createBaseGetTaskRequest(): GetTaskRequest {
  return { id: '', includeComments: false };
}

export const GetTaskRequest = {
  encode(message: GetTaskRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.id !== '') {
      writer.uint32(10).string(message.id);
    }
    if (message.includeComments !== false) {
      writer.uint32(16).bool(message.includeComments);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GetTaskRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetTaskRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.includeComments = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetTaskRequest {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : '',
      includeComments: isSet(object.includeComments)
        ? globalThis.Boolean(object.includeComments)
        : false,
    };
  },

  toJSON(message: GetTaskRequest): unknown {
    const obj: any = {};
    if (message.id !== '') {
      obj.id = message.id;
    }
    if (message.includeComments !== false) {
      obj.includeComments = message.includeComments;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetTaskRequest>, I>>(base?: I): GetTaskRequest {
    return GetTaskRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetTaskRequest>, I>>(object: I): GetTaskRequest {
    const message = createBaseGetTaskRequest();
    message.id = object.id ?? '';
    message.includeComments = object.includeComments ?? false;
    return message;
  },
};

function createBaseGetTaskResponse(): GetTaskResponse {
  return { task: undefined, found: false };
}

export const GetTaskResponse = {
  encode(message: GetTaskResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.task !== undefined) {
      Task.encode(message.task, writer.uint32(10).fork()).ldelim();
    }
    if (message.found !== false) {
      writer.uint32(16).bool(message.found);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GetTaskResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetTaskResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.task = Task.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.found = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetTaskResponse {
    return {
      task: isSet(object.task) ? Task.fromJSON(object.task) : undefined,
      found: isSet(object.found) ? globalThis.Boolean(object.found) : false,
    };
  },

  toJSON(message: GetTaskResponse): unknown {
    const obj: any = {};
    if (message.task !== undefined) {
      obj.task = Task.toJSON(message.task);
    }
    if (message.found !== false) {
      obj.found = message.found;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetTaskResponse>, I>>(base?: I): GetTaskResponse {
    return GetTaskResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetTaskResponse>, I>>(object: I): GetTaskResponse {
    const message = createBaseGetTaskResponse();
    message.task =
      object.task !== undefined && object.task !== null ? Task.fromPartial(object.task) : undefined;
    message.found = object.found ?? false;
    return message;
  },
};

function createBaseUpdateTaskRequest(): UpdateTaskRequest {
  return { id: '', task: undefined, updateMask: [] };
}

export const UpdateTaskRequest = {
  encode(message: UpdateTaskRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.id !== '') {
      writer.uint32(10).string(message.id);
    }
    if (message.task !== undefined) {
      Task.encode(message.task, writer.uint32(18).fork()).ldelim();
    }
    for (const v of message.updateMask) {
      writer.uint32(26).string(v!);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): UpdateTaskRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateTaskRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.task = Task.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.updateMask.push(reader.string());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UpdateTaskRequest {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : '',
      task: isSet(object.task) ? Task.fromJSON(object.task) : undefined,
      updateMask: globalThis.Array.isArray(object?.updateMask)
        ? object.updateMask.map((e: any) => globalThis.String(e))
        : [],
    };
  },

  toJSON(message: UpdateTaskRequest): unknown {
    const obj: any = {};
    if (message.id !== '') {
      obj.id = message.id;
    }
    if (message.task !== undefined) {
      obj.task = Task.toJSON(message.task);
    }
    if (message.updateMask?.length) {
      obj.updateMask = message.updateMask;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<UpdateTaskRequest>, I>>(base?: I): UpdateTaskRequest {
    return UpdateTaskRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<UpdateTaskRequest>, I>>(object: I): UpdateTaskRequest {
    const message = createBaseUpdateTaskRequest();
    message.id = object.id ?? '';
    message.task =
      object.task !== undefined && object.task !== null ? Task.fromPartial(object.task) : undefined;
    message.updateMask = object.updateMask?.map((e) => e) || [];
    return message;
  },
};

function createBaseUpdateTaskResponse(): UpdateTaskResponse {
  return { task: undefined, success: false, message: '' };
}

export const UpdateTaskResponse = {
  encode(message: UpdateTaskResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.task !== undefined) {
      Task.encode(message.task, writer.uint32(10).fork()).ldelim();
    }
    if (message.success !== false) {
      writer.uint32(16).bool(message.success);
    }
    if (message.message !== '') {
      writer.uint32(26).string(message.message);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): UpdateTaskResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateTaskResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.task = Task.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.success = reader.bool();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.message = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UpdateTaskResponse {
    return {
      task: isSet(object.task) ? Task.fromJSON(object.task) : undefined,
      success: isSet(object.success) ? globalThis.Boolean(object.success) : false,
      message: isSet(object.message) ? globalThis.String(object.message) : '',
    };
  },

  toJSON(message: UpdateTaskResponse): unknown {
    const obj: any = {};
    if (message.task !== undefined) {
      obj.task = Task.toJSON(message.task);
    }
    if (message.success !== false) {
      obj.success = message.success;
    }
    if (message.message !== '') {
      obj.message = message.message;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<UpdateTaskResponse>, I>>(base?: I): UpdateTaskResponse {
    return UpdateTaskResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<UpdateTaskResponse>, I>>(object: I): UpdateTaskResponse {
    const message = createBaseUpdateTaskResponse();
    message.task =
      object.task !== undefined && object.task !== null ? Task.fromPartial(object.task) : undefined;
    message.success = object.success ?? false;
    message.message = object.message ?? '';
    return message;
  },
};

function createBaseDeleteTaskRequest(): DeleteTaskRequest {
  return { id: '', force: false };
}

export const DeleteTaskRequest = {
  encode(message: DeleteTaskRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.id !== '') {
      writer.uint32(10).string(message.id);
    }
    if (message.force !== false) {
      writer.uint32(16).bool(message.force);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): DeleteTaskRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteTaskRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.force = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DeleteTaskRequest {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : '',
      force: isSet(object.force) ? globalThis.Boolean(object.force) : false,
    };
  },

  toJSON(message: DeleteTaskRequest): unknown {
    const obj: any = {};
    if (message.id !== '') {
      obj.id = message.id;
    }
    if (message.force !== false) {
      obj.force = message.force;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<DeleteTaskRequest>, I>>(base?: I): DeleteTaskRequest {
    return DeleteTaskRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DeleteTaskRequest>, I>>(object: I): DeleteTaskRequest {
    const message = createBaseDeleteTaskRequest();
    message.id = object.id ?? '';
    message.force = object.force ?? false;
    return message;
  },
};

function createBaseDeleteTaskResponse(): DeleteTaskResponse {
  return { success: false, message: '' };
}

export const DeleteTaskResponse = {
  encode(message: DeleteTaskResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.success !== false) {
      writer.uint32(8).bool(message.success);
    }
    if (message.message !== '') {
      writer.uint32(18).string(message.message);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): DeleteTaskResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteTaskResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.success = reader.bool();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.message = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DeleteTaskResponse {
    return {
      success: isSet(object.success) ? globalThis.Boolean(object.success) : false,
      message: isSet(object.message) ? globalThis.String(object.message) : '',
    };
  },

  toJSON(message: DeleteTaskResponse): unknown {
    const obj: any = {};
    if (message.success !== false) {
      obj.success = message.success;
    }
    if (message.message !== '') {
      obj.message = message.message;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<DeleteTaskResponse>, I>>(base?: I): DeleteTaskResponse {
    return DeleteTaskResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DeleteTaskResponse>, I>>(object: I): DeleteTaskResponse {
    const message = createBaseDeleteTaskResponse();
    message.success = object.success ?? false;
    message.message = object.message ?? '';
    return message;
  },
};

function createBaseListTasksRequest(): ListTasksRequest {
  return { pageSize: 0, pageToken: '', filter: undefined, sort: undefined };
}

export const ListTasksRequest = {
  encode(message: ListTasksRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.pageSize !== 0) {
      writer.uint32(8).int32(message.pageSize);
    }
    if (message.pageToken !== '') {
      writer.uint32(18).string(message.pageToken);
    }
    if (message.filter !== undefined) {
      TaskFilter.encode(message.filter, writer.uint32(26).fork()).ldelim();
    }
    if (message.sort !== undefined) {
      TaskSort.encode(message.sort, writer.uint32(34).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ListTasksRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListTasksRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.pageSize = reader.int32();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.pageToken = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.filter = TaskFilter.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.sort = TaskSort.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListTasksRequest {
    return {
      pageSize: isSet(object.pageSize) ? globalThis.Number(object.pageSize) : 0,
      pageToken: isSet(object.pageToken) ? globalThis.String(object.pageToken) : '',
      filter: isSet(object.filter) ? TaskFilter.fromJSON(object.filter) : undefined,
      sort: isSet(object.sort) ? TaskSort.fromJSON(object.sort) : undefined,
    };
  },

  toJSON(message: ListTasksRequest): unknown {
    const obj: any = {};
    if (message.pageSize !== 0) {
      obj.pageSize = Math.round(message.pageSize);
    }
    if (message.pageToken !== '') {
      obj.pageToken = message.pageToken;
    }
    if (message.filter !== undefined) {
      obj.filter = TaskFilter.toJSON(message.filter);
    }
    if (message.sort !== undefined) {
      obj.sort = TaskSort.toJSON(message.sort);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ListTasksRequest>, I>>(base?: I): ListTasksRequest {
    return ListTasksRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ListTasksRequest>, I>>(object: I): ListTasksRequest {
    const message = createBaseListTasksRequest();
    message.pageSize = object.pageSize ?? 0;
    message.pageToken = object.pageToken ?? '';
    message.filter =
      object.filter !== undefined && object.filter !== null
        ? TaskFilter.fromPartial(object.filter)
        : undefined;
    message.sort =
      object.sort !== undefined && object.sort !== null
        ? TaskSort.fromPartial(object.sort)
        : undefined;
    return message;
  },
};

function createBaseListTasksResponse(): ListTasksResponse {
  return { tasks: [], nextPageToken: '', totalCount: 0 };
}

export const ListTasksResponse = {
  encode(message: ListTasksResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.tasks) {
      Task.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    if (message.nextPageToken !== '') {
      writer.uint32(18).string(message.nextPageToken);
    }
    if (message.totalCount !== 0) {
      writer.uint32(24).int32(message.totalCount);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ListTasksResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListTasksResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.tasks.push(Task.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.nextPageToken = reader.string();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.totalCount = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListTasksResponse {
    return {
      tasks: globalThis.Array.isArray(object?.tasks)
        ? object.tasks.map((e: any) => Task.fromJSON(e))
        : [],
      nextPageToken: isSet(object.nextPageToken) ? globalThis.String(object.nextPageToken) : '',
      totalCount: isSet(object.totalCount) ? globalThis.Number(object.totalCount) : 0,
    };
  },

  toJSON(message: ListTasksResponse): unknown {
    const obj: any = {};
    if (message.tasks?.length) {
      obj.tasks = message.tasks.map((e) => Task.toJSON(e));
    }
    if (message.nextPageToken !== '') {
      obj.nextPageToken = message.nextPageToken;
    }
    if (message.totalCount !== 0) {
      obj.totalCount = Math.round(message.totalCount);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ListTasksResponse>, I>>(base?: I): ListTasksResponse {
    return ListTasksResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ListTasksResponse>, I>>(object: I): ListTasksResponse {
    const message = createBaseListTasksResponse();
    message.tasks = object.tasks?.map((e) => Task.fromPartial(e)) || [];
    message.nextPageToken = object.nextPageToken ?? '';
    message.totalCount = object.totalCount ?? 0;
    return message;
  },
};

function createBaseTaskFilter(): TaskFilter {
  return {
    status: [],
    priority: [],
    tags: [],
    assignedTo: '',
    dueBefore: undefined,
    dueAfter: undefined,
    searchQuery: '',
  };
}

export const TaskFilter = {
  encode(message: TaskFilter, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    writer.uint32(10).fork();
    for (const v of message.status) {
      writer.int32(v);
    }
    writer.ldelim();
    writer.uint32(18).fork();
    for (const v of message.priority) {
      writer.int32(v);
    }
    writer.ldelim();
    for (const v of message.tags) {
      writer.uint32(26).string(v!);
    }
    if (message.assignedTo !== '') {
      writer.uint32(34).string(message.assignedTo);
    }
    if (message.dueBefore !== undefined) {
      Timestamp.encode(toTimestamp(message.dueBefore), writer.uint32(42).fork()).ldelim();
    }
    if (message.dueAfter !== undefined) {
      Timestamp.encode(toTimestamp(message.dueAfter), writer.uint32(50).fork()).ldelim();
    }
    if (message.searchQuery !== '') {
      writer.uint32(58).string(message.searchQuery);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): TaskFilter {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTaskFilter();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag === 8) {
            message.status.push(reader.int32() as any);

            continue;
          }

          if (tag === 10) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.status.push(reader.int32() as any);
            }

            continue;
          }

          break;
        case 2:
          if (tag === 16) {
            message.priority.push(reader.int32() as any);

            continue;
          }

          if (tag === 18) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.priority.push(reader.int32() as any);
            }

            continue;
          }

          break;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.tags.push(reader.string());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.assignedTo = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.dueBefore = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.dueAfter = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.searchQuery = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TaskFilter {
    return {
      status: globalThis.Array.isArray(object?.status)
        ? object.status.map((e: any) => taskStatusFromJSON(e))
        : [],
      priority: globalThis.Array.isArray(object?.priority)
        ? object.priority.map((e: any) => taskPriorityFromJSON(e))
        : [],
      tags: globalThis.Array.isArray(object?.tags)
        ? object.tags.map((e: any) => globalThis.String(e))
        : [],
      assignedTo: isSet(object.assignedTo) ? globalThis.String(object.assignedTo) : '',
      dueBefore: isSet(object.dueBefore) ? fromJsonTimestamp(object.dueBefore) : undefined,
      dueAfter: isSet(object.dueAfter) ? fromJsonTimestamp(object.dueAfter) : undefined,
      searchQuery: isSet(object.searchQuery) ? globalThis.String(object.searchQuery) : '',
    };
  },

  toJSON(message: TaskFilter): unknown {
    const obj: any = {};
    if (message.status?.length) {
      obj.status = message.status.map((e) => taskStatusToJSON(e));
    }
    if (message.priority?.length) {
      obj.priority = message.priority.map((e) => taskPriorityToJSON(e));
    }
    if (message.tags?.length) {
      obj.tags = message.tags;
    }
    if (message.assignedTo !== '') {
      obj.assignedTo = message.assignedTo;
    }
    if (message.dueBefore !== undefined) {
      obj.dueBefore = message.dueBefore.toISOString();
    }
    if (message.dueAfter !== undefined) {
      obj.dueAfter = message.dueAfter.toISOString();
    }
    if (message.searchQuery !== '') {
      obj.searchQuery = message.searchQuery;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<TaskFilter>, I>>(base?: I): TaskFilter {
    return TaskFilter.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<TaskFilter>, I>>(object: I): TaskFilter {
    const message = createBaseTaskFilter();
    message.status = object.status?.map((e) => e) || [];
    message.priority = object.priority?.map((e) => e) || [];
    message.tags = object.tags?.map((e) => e) || [];
    message.assignedTo = object.assignedTo ?? '';
    message.dueBefore = object.dueBefore ?? undefined;
    message.dueAfter = object.dueAfter ?? undefined;
    message.searchQuery = object.searchQuery ?? '';
    return message;
  },
};

function createBaseTaskSort(): TaskSort {
  return { field: 0, direction: 0 };
}

export const TaskSort = {
  encode(message: TaskSort, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.field !== 0) {
      writer.uint32(8).int32(message.field);
    }
    if (message.direction !== 0) {
      writer.uint32(16).int32(message.direction);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): TaskSort {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTaskSort();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.field = reader.int32() as any;
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.direction = reader.int32() as any;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TaskSort {
    return {
      field: isSet(object.field) ? taskSortFieldFromJSON(object.field) : 0,
      direction: isSet(object.direction) ? sortDirectionFromJSON(object.direction) : 0,
    };
  },

  toJSON(message: TaskSort): unknown {
    const obj: any = {};
    if (message.field !== 0) {
      obj.field = taskSortFieldToJSON(message.field);
    }
    if (message.direction !== 0) {
      obj.direction = sortDirectionToJSON(message.direction);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<TaskSort>, I>>(base?: I): TaskSort {
    return TaskSort.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<TaskSort>, I>>(object: I): TaskSort {
    const message = createBaseTaskSort();
    message.field = object.field ?? 0;
    message.direction = object.direction ?? 0;
    return message;
  },
};

function createBaseBulkUpdateTasksRequest(): BulkUpdateTasksRequest {
  return { taskIds: [], status: 0, assignedTo: '', tagsToAdd: [], tagsToRemove: [] };
}

export const BulkUpdateTasksRequest = {
  encode(message: BulkUpdateTasksRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.taskIds) {
      writer.uint32(10).string(v!);
    }
    if (message.status !== 0) {
      writer.uint32(16).int32(message.status);
    }
    if (message.assignedTo !== '') {
      writer.uint32(26).string(message.assignedTo);
    }
    for (const v of message.tagsToAdd) {
      writer.uint32(34).string(v!);
    }
    for (const v of message.tagsToRemove) {
      writer.uint32(42).string(v!);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): BulkUpdateTasksRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBulkUpdateTasksRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.taskIds.push(reader.string());
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.status = reader.int32() as any;
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.assignedTo = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.tagsToAdd.push(reader.string());
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.tagsToRemove.push(reader.string());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BulkUpdateTasksRequest {
    return {
      taskIds: globalThis.Array.isArray(object?.taskIds)
        ? object.taskIds.map((e: any) => globalThis.String(e))
        : [],
      status: isSet(object.status) ? taskStatusFromJSON(object.status) : 0,
      assignedTo: isSet(object.assignedTo) ? globalThis.String(object.assignedTo) : '',
      tagsToAdd: globalThis.Array.isArray(object?.tagsToAdd)
        ? object.tagsToAdd.map((e: any) => globalThis.String(e))
        : [],
      tagsToRemove: globalThis.Array.isArray(object?.tagsToRemove)
        ? object.tagsToRemove.map((e: any) => globalThis.String(e))
        : [],
    };
  },

  toJSON(message: BulkUpdateTasksRequest): unknown {
    const obj: any = {};
    if (message.taskIds?.length) {
      obj.taskIds = message.taskIds;
    }
    if (message.status !== 0) {
      obj.status = taskStatusToJSON(message.status);
    }
    if (message.assignedTo !== '') {
      obj.assignedTo = message.assignedTo;
    }
    if (message.tagsToAdd?.length) {
      obj.tagsToAdd = message.tagsToAdd;
    }
    if (message.tagsToRemove?.length) {
      obj.tagsToRemove = message.tagsToRemove;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<BulkUpdateTasksRequest>, I>>(
    base?: I
  ): BulkUpdateTasksRequest {
    return BulkUpdateTasksRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<BulkUpdateTasksRequest>, I>>(
    object: I
  ): BulkUpdateTasksRequest {
    const message = createBaseBulkUpdateTasksRequest();
    message.taskIds = object.taskIds?.map((e) => e) || [];
    message.status = object.status ?? 0;
    message.assignedTo = object.assignedTo ?? '';
    message.tagsToAdd = object.tagsToAdd?.map((e) => e) || [];
    message.tagsToRemove = object.tagsToRemove?.map((e) => e) || [];
    return message;
  },
};

function createBaseBulkUpdateTasksResponse(): BulkUpdateTasksResponse {
  return { updatedCount: 0, failedIds: [], message: '' };
}

export const BulkUpdateTasksResponse = {
  encode(message: BulkUpdateTasksResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.updatedCount !== 0) {
      writer.uint32(8).int32(message.updatedCount);
    }
    for (const v of message.failedIds) {
      writer.uint32(18).string(v!);
    }
    if (message.message !== '') {
      writer.uint32(26).string(message.message);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): BulkUpdateTasksResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBulkUpdateTasksResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.updatedCount = reader.int32();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.failedIds.push(reader.string());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.message = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BulkUpdateTasksResponse {
    return {
      updatedCount: isSet(object.updatedCount) ? globalThis.Number(object.updatedCount) : 0,
      failedIds: globalThis.Array.isArray(object?.failedIds)
        ? object.failedIds.map((e: any) => globalThis.String(e))
        : [],
      message: isSet(object.message) ? globalThis.String(object.message) : '',
    };
  },

  toJSON(message: BulkUpdateTasksResponse): unknown {
    const obj: any = {};
    if (message.updatedCount !== 0) {
      obj.updatedCount = Math.round(message.updatedCount);
    }
    if (message.failedIds?.length) {
      obj.failedIds = message.failedIds;
    }
    if (message.message !== '') {
      obj.message = message.message;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<BulkUpdateTasksResponse>, I>>(
    base?: I
  ): BulkUpdateTasksResponse {
    return BulkUpdateTasksResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<BulkUpdateTasksResponse>, I>>(
    object: I
  ): BulkUpdateTasksResponse {
    const message = createBaseBulkUpdateTasksResponse();
    message.updatedCount = object.updatedCount ?? 0;
    message.failedIds = object.failedIds?.map((e) => e) || [];
    message.message = object.message ?? '';
    return message;
  },
};

function createBaseSearchTasksRequest(): SearchTasksRequest {
  return { query: '', filters: undefined, pageSize: 0, pageToken: '' };
}

export const SearchTasksRequest = {
  encode(message: SearchTasksRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.query !== '') {
      writer.uint32(10).string(message.query);
    }
    if (message.filters !== undefined) {
      TaskFilter.encode(message.filters, writer.uint32(18).fork()).ldelim();
    }
    if (message.pageSize !== 0) {
      writer.uint32(24).int32(message.pageSize);
    }
    if (message.pageToken !== '') {
      writer.uint32(34).string(message.pageToken);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): SearchTasksRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSearchTasksRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.query = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.filters = TaskFilter.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.pageSize = reader.int32();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.pageToken = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SearchTasksRequest {
    return {
      query: isSet(object.query) ? globalThis.String(object.query) : '',
      filters: isSet(object.filters) ? TaskFilter.fromJSON(object.filters) : undefined,
      pageSize: isSet(object.pageSize) ? globalThis.Number(object.pageSize) : 0,
      pageToken: isSet(object.pageToken) ? globalThis.String(object.pageToken) : '',
    };
  },

  toJSON(message: SearchTasksRequest): unknown {
    const obj: any = {};
    if (message.query !== '') {
      obj.query = message.query;
    }
    if (message.filters !== undefined) {
      obj.filters = TaskFilter.toJSON(message.filters);
    }
    if (message.pageSize !== 0) {
      obj.pageSize = Math.round(message.pageSize);
    }
    if (message.pageToken !== '') {
      obj.pageToken = message.pageToken;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SearchTasksRequest>, I>>(base?: I): SearchTasksRequest {
    return SearchTasksRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SearchTasksRequest>, I>>(object: I): SearchTasksRequest {
    const message = createBaseSearchTasksRequest();
    message.query = object.query ?? '';
    message.filters =
      object.filters !== undefined && object.filters !== null
        ? TaskFilter.fromPartial(object.filters)
        : undefined;
    message.pageSize = object.pageSize ?? 0;
    message.pageToken = object.pageToken ?? '';
    return message;
  },
};

function createBaseSearchTasksResponse(): SearchTasksResponse {
  return { tasks: [], totalCount: 0, searchTimeMs: 0 };
}

export const SearchTasksResponse = {
  encode(message: SearchTasksResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.tasks) {
      Task.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    if (message.totalCount !== 0) {
      writer.uint32(16).uint32(message.totalCount);
    }
    if (message.searchTimeMs !== 0) {
      writer.uint32(24).uint32(message.searchTimeMs);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): SearchTasksResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSearchTasksResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.tasks.push(Task.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.totalCount = reader.uint32();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.searchTimeMs = reader.uint32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SearchTasksResponse {
    return {
      tasks: globalThis.Array.isArray(object?.tasks)
        ? object.tasks.map((e: any) => Task.fromJSON(e))
        : [],
      totalCount: isSet(object.totalCount) ? globalThis.Number(object.totalCount) : 0,
      searchTimeMs: isSet(object.searchTimeMs) ? globalThis.Number(object.searchTimeMs) : 0,
    };
  },

  toJSON(message: SearchTasksResponse): unknown {
    const obj: any = {};
    if (message.tasks?.length) {
      obj.tasks = message.tasks.map((e) => Task.toJSON(e));
    }
    if (message.totalCount !== 0) {
      obj.totalCount = Math.round(message.totalCount);
    }
    if (message.searchTimeMs !== 0) {
      obj.searchTimeMs = Math.round(message.searchTimeMs);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SearchTasksResponse>, I>>(base?: I): SearchTasksResponse {
    return SearchTasksResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SearchTasksResponse>, I>>(
    object: I
  ): SearchTasksResponse {
    const message = createBaseSearchTasksResponse();
    message.tasks = object.tasks?.map((e) => Task.fromPartial(e)) || [];
    message.totalCount = object.totalCount ?? 0;
    message.searchTimeMs = object.searchTimeMs ?? 0;
    return message;
  },
};

function createBaseTaskEvent(): TaskEvent {
  return {
    eventId: '',
    eventType: 0,
    task: undefined,
    userId: '',
    timestamp: undefined,
    metadata: {},
  };
}

export const TaskEvent = {
  encode(message: TaskEvent, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.eventId !== '') {
      writer.uint32(10).string(message.eventId);
    }
    if (message.eventType !== 0) {
      writer.uint32(16).int32(message.eventType);
    }
    if (message.task !== undefined) {
      Task.encode(message.task, writer.uint32(26).fork()).ldelim();
    }
    if (message.userId !== '') {
      writer.uint32(34).string(message.userId);
    }
    if (message.timestamp !== undefined) {
      Timestamp.encode(toTimestamp(message.timestamp), writer.uint32(42).fork()).ldelim();
    }
    Object.entries(message.metadata).forEach(([key, value]) => {
      TaskEvent_MetadataEntry.encode({ key: key as any, value }, writer.uint32(50).fork()).ldelim();
    });
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): TaskEvent {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTaskEvent();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.eventId = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.eventType = reader.int32() as any;
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.task = Task.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.userId = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.timestamp = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          const entry6 = TaskEvent_MetadataEntry.decode(reader, reader.uint32());
          if (entry6.value !== undefined) {
            message.metadata[entry6.key] = entry6.value;
          }
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TaskEvent {
    return {
      eventId: isSet(object.eventId) ? globalThis.String(object.eventId) : '',
      eventType: isSet(object.eventType) ? taskEventTypeFromJSON(object.eventType) : 0,
      task: isSet(object.task) ? Task.fromJSON(object.task) : undefined,
      userId: isSet(object.userId) ? globalThis.String(object.userId) : '',
      timestamp: isSet(object.timestamp) ? fromJsonTimestamp(object.timestamp) : undefined,
      metadata: isObject(object.metadata)
        ? Object.entries(object.metadata).reduce<{ [key: string]: string }>((acc, [key, value]) => {
            acc[key] = String(value);
            return acc;
          }, {})
        : {},
    };
  },

  toJSON(message: TaskEvent): unknown {
    const obj: any = {};
    if (message.eventId !== '') {
      obj.eventId = message.eventId;
    }
    if (message.eventType !== 0) {
      obj.eventType = taskEventTypeToJSON(message.eventType);
    }
    if (message.task !== undefined) {
      obj.task = Task.toJSON(message.task);
    }
    if (message.userId !== '') {
      obj.userId = message.userId;
    }
    if (message.timestamp !== undefined) {
      obj.timestamp = message.timestamp.toISOString();
    }
    if (message.metadata) {
      const entries = Object.entries(message.metadata);
      if (entries.length > 0) {
        obj.metadata = {};
        entries.forEach(([k, v]) => {
          obj.metadata[k] = v;
        });
      }
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<TaskEvent>, I>>(base?: I): TaskEvent {
    return TaskEvent.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<TaskEvent>, I>>(object: I): TaskEvent {
    const message = createBaseTaskEvent();
    message.eventId = object.eventId ?? '';
    message.eventType = object.eventType ?? 0;
    message.task =
      object.task !== undefined && object.task !== null ? Task.fromPartial(object.task) : undefined;
    message.userId = object.userId ?? '';
    message.timestamp = object.timestamp ?? undefined;
    message.metadata = Object.entries(object.metadata ?? {}).reduce<{ [key: string]: string }>(
      (acc, [key, value]) => {
        if (value !== undefined) {
          acc[key] = globalThis.String(value);
        }
        return acc;
      },
      {}
    );
    return message;
  },
};

function createBaseTaskEvent_MetadataEntry(): TaskEvent_MetadataEntry {
  return { key: '', value: '' };
}

export const TaskEvent_MetadataEntry = {
  encode(message: TaskEvent_MetadataEntry, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.key !== '') {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== '') {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): TaskEvent_MetadataEntry {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTaskEvent_MetadataEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TaskEvent_MetadataEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : '',
      value: isSet(object.value) ? globalThis.String(object.value) : '',
    };
  },

  toJSON(message: TaskEvent_MetadataEntry): unknown {
    const obj: any = {};
    if (message.key !== '') {
      obj.key = message.key;
    }
    if (message.value !== '') {
      obj.value = message.value;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<TaskEvent_MetadataEntry>, I>>(
    base?: I
  ): TaskEvent_MetadataEntry {
    return TaskEvent_MetadataEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<TaskEvent_MetadataEntry>, I>>(
    object: I
  ): TaskEvent_MetadataEntry {
    const message = createBaseTaskEvent_MetadataEntry();
    message.key = object.key ?? '';
    message.value = object.value ?? '';
    return message;
  },
};

function createBaseStreamTaskEventsRequest(): StreamTaskEventsRequest {
  return { taskIds: [], eventTypes: [], userId: '' };
}

export const StreamTaskEventsRequest = {
  encode(message: StreamTaskEventsRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.taskIds) {
      writer.uint32(10).string(v!);
    }
    writer.uint32(18).fork();
    for (const v of message.eventTypes) {
      writer.int32(v);
    }
    writer.ldelim();
    if (message.userId !== '') {
      writer.uint32(26).string(message.userId);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): StreamTaskEventsRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStreamTaskEventsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.taskIds.push(reader.string());
          continue;
        case 2:
          if (tag === 16) {
            message.eventTypes.push(reader.int32() as any);

            continue;
          }

          if (tag === 18) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.eventTypes.push(reader.int32() as any);
            }

            continue;
          }

          break;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.userId = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): StreamTaskEventsRequest {
    return {
      taskIds: globalThis.Array.isArray(object?.taskIds)
        ? object.taskIds.map((e: any) => globalThis.String(e))
        : [],
      eventTypes: globalThis.Array.isArray(object?.eventTypes)
        ? object.eventTypes.map((e: any) => taskEventTypeFromJSON(e))
        : [],
      userId: isSet(object.userId) ? globalThis.String(object.userId) : '',
    };
  },

  toJSON(message: StreamTaskEventsRequest): unknown {
    const obj: any = {};
    if (message.taskIds?.length) {
      obj.taskIds = message.taskIds;
    }
    if (message.eventTypes?.length) {
      obj.eventTypes = message.eventTypes.map((e) => taskEventTypeToJSON(e));
    }
    if (message.userId !== '') {
      obj.userId = message.userId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<StreamTaskEventsRequest>, I>>(
    base?: I
  ): StreamTaskEventsRequest {
    return StreamTaskEventsRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<StreamTaskEventsRequest>, I>>(
    object: I
  ): StreamTaskEventsRequest {
    const message = createBaseStreamTaskEventsRequest();
    message.taskIds = object.taskIds?.map((e) => e) || [];
    message.eventTypes = object.eventTypes?.map((e) => e) || [];
    message.userId = object.userId ?? '';
    return message;
  },
};

function createBaseGetTaskAnalyticsRequest(): GetTaskAnalyticsRequest {
  return { startDate: undefined, endDate: undefined, userIds: [], groupBy: '' };
}

export const GetTaskAnalyticsRequest = {
  encode(message: GetTaskAnalyticsRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.startDate !== undefined) {
      Timestamp.encode(toTimestamp(message.startDate), writer.uint32(10).fork()).ldelim();
    }
    if (message.endDate !== undefined) {
      Timestamp.encode(toTimestamp(message.endDate), writer.uint32(18).fork()).ldelim();
    }
    for (const v of message.userIds) {
      writer.uint32(26).string(v!);
    }
    if (message.groupBy !== '') {
      writer.uint32(34).string(message.groupBy);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GetTaskAnalyticsRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetTaskAnalyticsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.startDate = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.endDate = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.userIds.push(reader.string());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.groupBy = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetTaskAnalyticsRequest {
    return {
      startDate: isSet(object.startDate) ? fromJsonTimestamp(object.startDate) : undefined,
      endDate: isSet(object.endDate) ? fromJsonTimestamp(object.endDate) : undefined,
      userIds: globalThis.Array.isArray(object?.userIds)
        ? object.userIds.map((e: any) => globalThis.String(e))
        : [],
      groupBy: isSet(object.groupBy) ? globalThis.String(object.groupBy) : '',
    };
  },

  toJSON(message: GetTaskAnalyticsRequest): unknown {
    const obj: any = {};
    if (message.startDate !== undefined) {
      obj.startDate = message.startDate.toISOString();
    }
    if (message.endDate !== undefined) {
      obj.endDate = message.endDate.toISOString();
    }
    if (message.userIds?.length) {
      obj.userIds = message.userIds;
    }
    if (message.groupBy !== '') {
      obj.groupBy = message.groupBy;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetTaskAnalyticsRequest>, I>>(
    base?: I
  ): GetTaskAnalyticsRequest {
    return GetTaskAnalyticsRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetTaskAnalyticsRequest>, I>>(
    object: I
  ): GetTaskAnalyticsRequest {
    const message = createBaseGetTaskAnalyticsRequest();
    message.startDate = object.startDate ?? undefined;
    message.endDate = object.endDate ?? undefined;
    message.userIds = object.userIds?.map((e) => e) || [];
    message.groupBy = object.groupBy ?? '';
    return message;
  },
};

function createBaseGetTaskAnalyticsResponse(): GetTaskAnalyticsResponse {
  return { analytics: undefined, generatedAt: undefined };
}

export const GetTaskAnalyticsResponse = {
  encode(message: GetTaskAnalyticsResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.analytics !== undefined) {
      TaskAnalytics.encode(message.analytics, writer.uint32(10).fork()).ldelim();
    }
    if (message.generatedAt !== undefined) {
      Timestamp.encode(toTimestamp(message.generatedAt), writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GetTaskAnalyticsResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetTaskAnalyticsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.analytics = TaskAnalytics.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.generatedAt = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetTaskAnalyticsResponse {
    return {
      analytics: isSet(object.analytics) ? TaskAnalytics.fromJSON(object.analytics) : undefined,
      generatedAt: isSet(object.generatedAt) ? fromJsonTimestamp(object.generatedAt) : undefined,
    };
  },

  toJSON(message: GetTaskAnalyticsResponse): unknown {
    const obj: any = {};
    if (message.analytics !== undefined) {
      obj.analytics = TaskAnalytics.toJSON(message.analytics);
    }
    if (message.generatedAt !== undefined) {
      obj.generatedAt = message.generatedAt.toISOString();
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetTaskAnalyticsResponse>, I>>(
    base?: I
  ): GetTaskAnalyticsResponse {
    return GetTaskAnalyticsResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetTaskAnalyticsResponse>, I>>(
    object: I
  ): GetTaskAnalyticsResponse {
    const message = createBaseGetTaskAnalyticsResponse();
    message.analytics =
      object.analytics !== undefined && object.analytics !== null
        ? TaskAnalytics.fromPartial(object.analytics)
        : undefined;
    message.generatedAt = object.generatedAt ?? undefined;
    return message;
  },
};

function createBaseTaskAnalytics(): TaskAnalytics {
  return {
    totalTasks: 0,
    completedTasks: 0,
    inProgressTasks: 0,
    todoTasks: 0,
    completionRate: 0,
    averageCompletionTimeHours: 0,
    overdueTasks: 0,
    tasksByPriority: {},
    tasksCreatedThisWeek: 0,
    tasksCompletedThisWeek: 0,
  };
}

export const TaskAnalytics = {
  encode(message: TaskAnalytics, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.totalTasks !== 0) {
      writer.uint32(8).uint32(message.totalTasks);
    }
    if (message.completedTasks !== 0) {
      writer.uint32(16).uint32(message.completedTasks);
    }
    if (message.inProgressTasks !== 0) {
      writer.uint32(24).uint32(message.inProgressTasks);
    }
    if (message.todoTasks !== 0) {
      writer.uint32(32).uint32(message.todoTasks);
    }
    if (message.completionRate !== 0) {
      writer.uint32(45).float(message.completionRate);
    }
    if (message.averageCompletionTimeHours !== 0) {
      writer.uint32(53).float(message.averageCompletionTimeHours);
    }
    if (message.overdueTasks !== 0) {
      writer.uint32(56).uint32(message.overdueTasks);
    }
    Object.entries(message.tasksByPriority).forEach(([key, value]) => {
      TaskAnalytics_TasksByPriorityEntry.encode(
        { key: key as any, value },
        writer.uint32(66).fork()
      ).ldelim();
    });
    if (message.tasksCreatedThisWeek !== 0) {
      writer.uint32(72).uint32(message.tasksCreatedThisWeek);
    }
    if (message.tasksCompletedThisWeek !== 0) {
      writer.uint32(80).uint32(message.tasksCompletedThisWeek);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): TaskAnalytics {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTaskAnalytics();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.totalTasks = reader.uint32();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.completedTasks = reader.uint32();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.inProgressTasks = reader.uint32();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.todoTasks = reader.uint32();
          continue;
        case 5:
          if (tag !== 45) {
            break;
          }

          message.completionRate = reader.float();
          continue;
        case 6:
          if (tag !== 53) {
            break;
          }

          message.averageCompletionTimeHours = reader.float();
          continue;
        case 7:
          if (tag !== 56) {
            break;
          }

          message.overdueTasks = reader.uint32();
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          const entry8 = TaskAnalytics_TasksByPriorityEntry.decode(reader, reader.uint32());
          if (entry8.value !== undefined) {
            message.tasksByPriority[entry8.key] = entry8.value;
          }
          continue;
        case 9:
          if (tag !== 72) {
            break;
          }

          message.tasksCreatedThisWeek = reader.uint32();
          continue;
        case 10:
          if (tag !== 80) {
            break;
          }

          message.tasksCompletedThisWeek = reader.uint32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TaskAnalytics {
    return {
      totalTasks: isSet(object.totalTasks) ? globalThis.Number(object.totalTasks) : 0,
      completedTasks: isSet(object.completedTasks) ? globalThis.Number(object.completedTasks) : 0,
      inProgressTasks: isSet(object.inProgressTasks)
        ? globalThis.Number(object.inProgressTasks)
        : 0,
      todoTasks: isSet(object.todoTasks) ? globalThis.Number(object.todoTasks) : 0,
      completionRate: isSet(object.completionRate) ? globalThis.Number(object.completionRate) : 0,
      averageCompletionTimeHours: isSet(object.averageCompletionTimeHours)
        ? globalThis.Number(object.averageCompletionTimeHours)
        : 0,
      overdueTasks: isSet(object.overdueTasks) ? globalThis.Number(object.overdueTasks) : 0,
      tasksByPriority: isObject(object.tasksByPriority)
        ? Object.entries(object.tasksByPriority).reduce<{ [key: number]: number }>(
            (acc, [key, value]) => {
              acc[globalThis.Number(key)] = Number(value);
              return acc;
            },
            {}
          )
        : {},
      tasksCreatedThisWeek: isSet(object.tasksCreatedThisWeek)
        ? globalThis.Number(object.tasksCreatedThisWeek)
        : 0,
      tasksCompletedThisWeek: isSet(object.tasksCompletedThisWeek)
        ? globalThis.Number(object.tasksCompletedThisWeek)
        : 0,
    };
  },

  toJSON(message: TaskAnalytics): unknown {
    const obj: any = {};
    if (message.totalTasks !== 0) {
      obj.totalTasks = Math.round(message.totalTasks);
    }
    if (message.completedTasks !== 0) {
      obj.completedTasks = Math.round(message.completedTasks);
    }
    if (message.inProgressTasks !== 0) {
      obj.inProgressTasks = Math.round(message.inProgressTasks);
    }
    if (message.todoTasks !== 0) {
      obj.todoTasks = Math.round(message.todoTasks);
    }
    if (message.completionRate !== 0) {
      obj.completionRate = message.completionRate;
    }
    if (message.averageCompletionTimeHours !== 0) {
      obj.averageCompletionTimeHours = message.averageCompletionTimeHours;
    }
    if (message.overdueTasks !== 0) {
      obj.overdueTasks = Math.round(message.overdueTasks);
    }
    if (message.tasksByPriority) {
      const entries = Object.entries(message.tasksByPriority);
      if (entries.length > 0) {
        obj.tasksByPriority = {};
        entries.forEach(([k, v]) => {
          obj.tasksByPriority[k] = Math.round(v);
        });
      }
    }
    if (message.tasksCreatedThisWeek !== 0) {
      obj.tasksCreatedThisWeek = Math.round(message.tasksCreatedThisWeek);
    }
    if (message.tasksCompletedThisWeek !== 0) {
      obj.tasksCompletedThisWeek = Math.round(message.tasksCompletedThisWeek);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<TaskAnalytics>, I>>(base?: I): TaskAnalytics {
    return TaskAnalytics.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<TaskAnalytics>, I>>(object: I): TaskAnalytics {
    const message = createBaseTaskAnalytics();
    message.totalTasks = object.totalTasks ?? 0;
    message.completedTasks = object.completedTasks ?? 0;
    message.inProgressTasks = object.inProgressTasks ?? 0;
    message.todoTasks = object.todoTasks ?? 0;
    message.completionRate = object.completionRate ?? 0;
    message.averageCompletionTimeHours = object.averageCompletionTimeHours ?? 0;
    message.overdueTasks = object.overdueTasks ?? 0;
    message.tasksByPriority = Object.entries(object.tasksByPriority ?? {}).reduce<{
      [key: number]: number;
    }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[globalThis.Number(key)] = globalThis.Number(value);
      }
      return acc;
    }, {});
    message.tasksCreatedThisWeek = object.tasksCreatedThisWeek ?? 0;
    message.tasksCompletedThisWeek = object.tasksCompletedThisWeek ?? 0;
    return message;
  },
};

function createBaseTaskAnalytics_TasksByPriorityEntry(): TaskAnalytics_TasksByPriorityEntry {
  return { key: 0, value: 0 };
}

export const TaskAnalytics_TasksByPriorityEntry = {
  encode(
    message: TaskAnalytics_TasksByPriorityEntry,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    if (message.key !== 0) {
      writer.uint32(8).int32(message.key);
    }
    if (message.value !== 0) {
      writer.uint32(16).uint32(message.value);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): TaskAnalytics_TasksByPriorityEntry {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTaskAnalytics_TasksByPriorityEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.key = reader.int32();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.value = reader.uint32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TaskAnalytics_TasksByPriorityEntry {
    return {
      key: isSet(object.key) ? globalThis.Number(object.key) : 0,
      value: isSet(object.value) ? globalThis.Number(object.value) : 0,
    };
  },

  toJSON(message: TaskAnalytics_TasksByPriorityEntry): unknown {
    const obj: any = {};
    if (message.key !== 0) {
      obj.key = Math.round(message.key);
    }
    if (message.value !== 0) {
      obj.value = Math.round(message.value);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<TaskAnalytics_TasksByPriorityEntry>, I>>(
    base?: I
  ): TaskAnalytics_TasksByPriorityEntry {
    return TaskAnalytics_TasksByPriorityEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<TaskAnalytics_TasksByPriorityEntry>, I>>(
    object: I
  ): TaskAnalytics_TasksByPriorityEntry {
    const message = createBaseTaskAnalytics_TasksByPriorityEntry();
    message.key = object.key ?? 0;
    message.value = object.value ?? 0;
    return message;
  },
};

function createBaseTaskMetricPoint(): TaskMetricPoint {
  return { label: '', count: 0, value: 0, timestamp: undefined };
}

export const TaskMetricPoint = {
  encode(message: TaskMetricPoint, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.label !== '') {
      writer.uint32(10).string(message.label);
    }
    if (message.count !== 0) {
      writer.uint32(16).int32(message.count);
    }
    if (message.value !== 0) {
      writer.uint32(25).double(message.value);
    }
    if (message.timestamp !== undefined) {
      Timestamp.encode(toTimestamp(message.timestamp), writer.uint32(34).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): TaskMetricPoint {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTaskMetricPoint();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.label = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.count = reader.int32();
          continue;
        case 3:
          if (tag !== 25) {
            break;
          }

          message.value = reader.double();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.timestamp = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TaskMetricPoint {
    return {
      label: isSet(object.label) ? globalThis.String(object.label) : '',
      count: isSet(object.count) ? globalThis.Number(object.count) : 0,
      value: isSet(object.value) ? globalThis.Number(object.value) : 0,
      timestamp: isSet(object.timestamp) ? fromJsonTimestamp(object.timestamp) : undefined,
    };
  },

  toJSON(message: TaskMetricPoint): unknown {
    const obj: any = {};
    if (message.label !== '') {
      obj.label = message.label;
    }
    if (message.count !== 0) {
      obj.count = Math.round(message.count);
    }
    if (message.value !== 0) {
      obj.value = message.value;
    }
    if (message.timestamp !== undefined) {
      obj.timestamp = message.timestamp.toISOString();
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<TaskMetricPoint>, I>>(base?: I): TaskMetricPoint {
    return TaskMetricPoint.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<TaskMetricPoint>, I>>(object: I): TaskMetricPoint {
    const message = createBaseTaskMetricPoint();
    message.label = object.label ?? '';
    message.count = object.count ?? 0;
    message.value = object.value ?? 0;
    message.timestamp = object.timestamp ?? undefined;
    return message;
  },
};

function createBaseTaskSummary(): TaskSummary {
  return {
    totalTasks: 0,
    completedTasks: 0,
    completionRate: 0,
    averageCompletionTimeHours: 0,
    overdueTasks: 0,
  };
}

export const TaskSummary = {
  encode(message: TaskSummary, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.totalTasks !== 0) {
      writer.uint32(8).int32(message.totalTasks);
    }
    if (message.completedTasks !== 0) {
      writer.uint32(16).int32(message.completedTasks);
    }
    if (message.completionRate !== 0) {
      writer.uint32(25).double(message.completionRate);
    }
    if (message.averageCompletionTimeHours !== 0) {
      writer.uint32(33).double(message.averageCompletionTimeHours);
    }
    if (message.overdueTasks !== 0) {
      writer.uint32(40).int32(message.overdueTasks);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): TaskSummary {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTaskSummary();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.totalTasks = reader.int32();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.completedTasks = reader.int32();
          continue;
        case 3:
          if (tag !== 25) {
            break;
          }

          message.completionRate = reader.double();
          continue;
        case 4:
          if (tag !== 33) {
            break;
          }

          message.averageCompletionTimeHours = reader.double();
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.overdueTasks = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TaskSummary {
    return {
      totalTasks: isSet(object.totalTasks) ? globalThis.Number(object.totalTasks) : 0,
      completedTasks: isSet(object.completedTasks) ? globalThis.Number(object.completedTasks) : 0,
      completionRate: isSet(object.completionRate) ? globalThis.Number(object.completionRate) : 0,
      averageCompletionTimeHours: isSet(object.averageCompletionTimeHours)
        ? globalThis.Number(object.averageCompletionTimeHours)
        : 0,
      overdueTasks: isSet(object.overdueTasks) ? globalThis.Number(object.overdueTasks) : 0,
    };
  },

  toJSON(message: TaskSummary): unknown {
    const obj: any = {};
    if (message.totalTasks !== 0) {
      obj.totalTasks = Math.round(message.totalTasks);
    }
    if (message.completedTasks !== 0) {
      obj.completedTasks = Math.round(message.completedTasks);
    }
    if (message.completionRate !== 0) {
      obj.completionRate = message.completionRate;
    }
    if (message.averageCompletionTimeHours !== 0) {
      obj.averageCompletionTimeHours = message.averageCompletionTimeHours;
    }
    if (message.overdueTasks !== 0) {
      obj.overdueTasks = Math.round(message.overdueTasks);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<TaskSummary>, I>>(base?: I): TaskSummary {
    return TaskSummary.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<TaskSummary>, I>>(object: I): TaskSummary {
    const message = createBaseTaskSummary();
    message.totalTasks = object.totalTasks ?? 0;
    message.completedTasks = object.completedTasks ?? 0;
    message.completionRate = object.completionRate ?? 0;
    message.averageCompletionTimeHours = object.averageCompletionTimeHours ?? 0;
    message.overdueTasks = object.overdueTasks ?? 0;
    return message;
  },
};

function createBaseUploadTaskAttachmentRequest(): UploadTaskAttachmentRequest {
  return {
    taskId: '',
    chunk: new Uint8Array(0),
    filename: '',
    contentType: '',
    totalSize: 0,
    chunkIndex: 0,
    isFinalChunk: false,
  };
}

export const UploadTaskAttachmentRequest = {
  encode(
    message: UploadTaskAttachmentRequest,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    if (message.taskId !== '') {
      writer.uint32(10).string(message.taskId);
    }
    if (message.chunk.length !== 0) {
      writer.uint32(18).bytes(message.chunk);
    }
    if (message.filename !== '') {
      writer.uint32(26).string(message.filename);
    }
    if (message.contentType !== '') {
      writer.uint32(34).string(message.contentType);
    }
    if (message.totalSize !== 0) {
      writer.uint32(40).int64(message.totalSize);
    }
    if (message.chunkIndex !== 0) {
      writer.uint32(48).int32(message.chunkIndex);
    }
    if (message.isFinalChunk !== false) {
      writer.uint32(56).bool(message.isFinalChunk);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): UploadTaskAttachmentRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUploadTaskAttachmentRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.taskId = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.chunk = reader.bytes();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.filename = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.contentType = reader.string();
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.totalSize = longToNumber(reader.int64() as Long);
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.chunkIndex = reader.int32();
          continue;
        case 7:
          if (tag !== 56) {
            break;
          }

          message.isFinalChunk = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UploadTaskAttachmentRequest {
    return {
      taskId: isSet(object.taskId) ? globalThis.String(object.taskId) : '',
      chunk: isSet(object.chunk) ? bytesFromBase64(object.chunk) : new Uint8Array(0),
      filename: isSet(object.filename) ? globalThis.String(object.filename) : '',
      contentType: isSet(object.contentType) ? globalThis.String(object.contentType) : '',
      totalSize: isSet(object.totalSize) ? globalThis.Number(object.totalSize) : 0,
      chunkIndex: isSet(object.chunkIndex) ? globalThis.Number(object.chunkIndex) : 0,
      isFinalChunk: isSet(object.isFinalChunk) ? globalThis.Boolean(object.isFinalChunk) : false,
    };
  },

  toJSON(message: UploadTaskAttachmentRequest): unknown {
    const obj: any = {};
    if (message.taskId !== '') {
      obj.taskId = message.taskId;
    }
    if (message.chunk.length !== 0) {
      obj.chunk = base64FromBytes(message.chunk);
    }
    if (message.filename !== '') {
      obj.filename = message.filename;
    }
    if (message.contentType !== '') {
      obj.contentType = message.contentType;
    }
    if (message.totalSize !== 0) {
      obj.totalSize = Math.round(message.totalSize);
    }
    if (message.chunkIndex !== 0) {
      obj.chunkIndex = Math.round(message.chunkIndex);
    }
    if (message.isFinalChunk !== false) {
      obj.isFinalChunk = message.isFinalChunk;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<UploadTaskAttachmentRequest>, I>>(
    base?: I
  ): UploadTaskAttachmentRequest {
    return UploadTaskAttachmentRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<UploadTaskAttachmentRequest>, I>>(
    object: I
  ): UploadTaskAttachmentRequest {
    const message = createBaseUploadTaskAttachmentRequest();
    message.taskId = object.taskId ?? '';
    message.chunk = object.chunk ?? new Uint8Array(0);
    message.filename = object.filename ?? '';
    message.contentType = object.contentType ?? '';
    message.totalSize = object.totalSize ?? 0;
    message.chunkIndex = object.chunkIndex ?? 0;
    message.isFinalChunk = object.isFinalChunk ?? false;
    return message;
  },
};

function createBaseUploadTaskAttachmentResponse(): UploadTaskAttachmentResponse {
  return { attachmentId: '', filename: '', fileSize: 0, success: false, message: '' };
}

export const UploadTaskAttachmentResponse = {
  encode(
    message: UploadTaskAttachmentResponse,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    if (message.attachmentId !== '') {
      writer.uint32(10).string(message.attachmentId);
    }
    if (message.filename !== '') {
      writer.uint32(18).string(message.filename);
    }
    if (message.fileSize !== 0) {
      writer.uint32(24).uint64(message.fileSize);
    }
    if (message.success !== false) {
      writer.uint32(32).bool(message.success);
    }
    if (message.message !== '') {
      writer.uint32(42).string(message.message);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): UploadTaskAttachmentResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUploadTaskAttachmentResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.attachmentId = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.filename = reader.string();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.fileSize = longToNumber(reader.uint64() as Long);
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.success = reader.bool();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.message = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UploadTaskAttachmentResponse {
    return {
      attachmentId: isSet(object.attachmentId) ? globalThis.String(object.attachmentId) : '',
      filename: isSet(object.filename) ? globalThis.String(object.filename) : '',
      fileSize: isSet(object.fileSize) ? globalThis.Number(object.fileSize) : 0,
      success: isSet(object.success) ? globalThis.Boolean(object.success) : false,
      message: isSet(object.message) ? globalThis.String(object.message) : '',
    };
  },

  toJSON(message: UploadTaskAttachmentResponse): unknown {
    const obj: any = {};
    if (message.attachmentId !== '') {
      obj.attachmentId = message.attachmentId;
    }
    if (message.filename !== '') {
      obj.filename = message.filename;
    }
    if (message.fileSize !== 0) {
      obj.fileSize = Math.round(message.fileSize);
    }
    if (message.success !== false) {
      obj.success = message.success;
    }
    if (message.message !== '') {
      obj.message = message.message;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<UploadTaskAttachmentResponse>, I>>(
    base?: I
  ): UploadTaskAttachmentResponse {
    return UploadTaskAttachmentResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<UploadTaskAttachmentResponse>, I>>(
    object: I
  ): UploadTaskAttachmentResponse {
    const message = createBaseUploadTaskAttachmentResponse();
    message.attachmentId = object.attachmentId ?? '';
    message.filename = object.filename ?? '';
    message.fileSize = object.fileSize ?? 0;
    message.success = object.success ?? false;
    message.message = object.message ?? '';
    return message;
  },
};

function createBaseCreateUserRequest(): CreateUserRequest {
  return { username: '', email: '', password: '', fullName: '', role: 0 };
}

export const CreateUserRequest = {
  encode(message: CreateUserRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.username !== '') {
      writer.uint32(10).string(message.username);
    }
    if (message.email !== '') {
      writer.uint32(18).string(message.email);
    }
    if (message.password !== '') {
      writer.uint32(26).string(message.password);
    }
    if (message.fullName !== '') {
      writer.uint32(34).string(message.fullName);
    }
    if (message.role !== 0) {
      writer.uint32(40).int32(message.role);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CreateUserRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateUserRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.username = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.email = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.password = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.fullName = reader.string();
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.role = reader.int32() as any;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateUserRequest {
    return {
      username: isSet(object.username) ? globalThis.String(object.username) : '',
      email: isSet(object.email) ? globalThis.String(object.email) : '',
      password: isSet(object.password) ? globalThis.String(object.password) : '',
      fullName: isSet(object.fullName) ? globalThis.String(object.fullName) : '',
      role: isSet(object.role) ? userRoleFromJSON(object.role) : 0,
    };
  },

  toJSON(message: CreateUserRequest): unknown {
    const obj: any = {};
    if (message.username !== '') {
      obj.username = message.username;
    }
    if (message.email !== '') {
      obj.email = message.email;
    }
    if (message.password !== '') {
      obj.password = message.password;
    }
    if (message.fullName !== '') {
      obj.fullName = message.fullName;
    }
    if (message.role !== 0) {
      obj.role = userRoleToJSON(message.role);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CreateUserRequest>, I>>(base?: I): CreateUserRequest {
    return CreateUserRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CreateUserRequest>, I>>(object: I): CreateUserRequest {
    const message = createBaseCreateUserRequest();
    message.username = object.username ?? '';
    message.email = object.email ?? '';
    message.password = object.password ?? '';
    message.fullName = object.fullName ?? '';
    message.role = object.role ?? 0;
    return message;
  },
};

function createBaseCreateUserResponse(): CreateUserResponse {
  return { user: undefined, success: false, message: '' };
}

export const CreateUserResponse = {
  encode(message: CreateUserResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.user !== undefined) {
      User.encode(message.user, writer.uint32(10).fork()).ldelim();
    }
    if (message.success !== false) {
      writer.uint32(16).bool(message.success);
    }
    if (message.message !== '') {
      writer.uint32(26).string(message.message);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CreateUserResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateUserResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.user = User.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.success = reader.bool();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.message = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateUserResponse {
    return {
      user: isSet(object.user) ? User.fromJSON(object.user) : undefined,
      success: isSet(object.success) ? globalThis.Boolean(object.success) : false,
      message: isSet(object.message) ? globalThis.String(object.message) : '',
    };
  },

  toJSON(message: CreateUserResponse): unknown {
    const obj: any = {};
    if (message.user !== undefined) {
      obj.user = User.toJSON(message.user);
    }
    if (message.success !== false) {
      obj.success = message.success;
    }
    if (message.message !== '') {
      obj.message = message.message;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CreateUserResponse>, I>>(base?: I): CreateUserResponse {
    return CreateUserResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CreateUserResponse>, I>>(object: I): CreateUserResponse {
    const message = createBaseCreateUserResponse();
    message.user =
      object.user !== undefined && object.user !== null ? User.fromPartial(object.user) : undefined;
    message.success = object.success ?? false;
    message.message = object.message ?? '';
    return message;
  },
};

function createBaseGetUserRequest(): GetUserRequest {
  return { id: '' };
}

export const GetUserRequest = {
  encode(message: GetUserRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.id !== '') {
      writer.uint32(10).string(message.id);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GetUserRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetUserRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetUserRequest {
    return { id: isSet(object.id) ? globalThis.String(object.id) : '' };
  },

  toJSON(message: GetUserRequest): unknown {
    const obj: any = {};
    if (message.id !== '') {
      obj.id = message.id;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetUserRequest>, I>>(base?: I): GetUserRequest {
    return GetUserRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetUserRequest>, I>>(object: I): GetUserRequest {
    const message = createBaseGetUserRequest();
    message.id = object.id ?? '';
    return message;
  },
};

function createBaseGetUserResponse(): GetUserResponse {
  return { user: undefined, found: false };
}

export const GetUserResponse = {
  encode(message: GetUserResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.user !== undefined) {
      User.encode(message.user, writer.uint32(10).fork()).ldelim();
    }
    if (message.found !== false) {
      writer.uint32(16).bool(message.found);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GetUserResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetUserResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.user = User.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.found = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetUserResponse {
    return {
      user: isSet(object.user) ? User.fromJSON(object.user) : undefined,
      found: isSet(object.found) ? globalThis.Boolean(object.found) : false,
    };
  },

  toJSON(message: GetUserResponse): unknown {
    const obj: any = {};
    if (message.user !== undefined) {
      obj.user = User.toJSON(message.user);
    }
    if (message.found !== false) {
      obj.found = message.found;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetUserResponse>, I>>(base?: I): GetUserResponse {
    return GetUserResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetUserResponse>, I>>(object: I): GetUserResponse {
    const message = createBaseGetUserResponse();
    message.user =
      object.user !== undefined && object.user !== null ? User.fromPartial(object.user) : undefined;
    message.found = object.found ?? false;
    return message;
  },
};

function createBaseListUsersRequest(): ListUsersRequest {
  return { pageSize: 0, pageToken: '', role: 0, activeOnly: false };
}

export const ListUsersRequest = {
  encode(message: ListUsersRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.pageSize !== 0) {
      writer.uint32(8).int32(message.pageSize);
    }
    if (message.pageToken !== '') {
      writer.uint32(18).string(message.pageToken);
    }
    if (message.role !== 0) {
      writer.uint32(24).int32(message.role);
    }
    if (message.activeOnly !== false) {
      writer.uint32(32).bool(message.activeOnly);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ListUsersRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListUsersRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.pageSize = reader.int32();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.pageToken = reader.string();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.role = reader.int32() as any;
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.activeOnly = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListUsersRequest {
    return {
      pageSize: isSet(object.pageSize) ? globalThis.Number(object.pageSize) : 0,
      pageToken: isSet(object.pageToken) ? globalThis.String(object.pageToken) : '',
      role: isSet(object.role) ? userRoleFromJSON(object.role) : 0,
      activeOnly: isSet(object.activeOnly) ? globalThis.Boolean(object.activeOnly) : false,
    };
  },

  toJSON(message: ListUsersRequest): unknown {
    const obj: any = {};
    if (message.pageSize !== 0) {
      obj.pageSize = Math.round(message.pageSize);
    }
    if (message.pageToken !== '') {
      obj.pageToken = message.pageToken;
    }
    if (message.role !== 0) {
      obj.role = userRoleToJSON(message.role);
    }
    if (message.activeOnly !== false) {
      obj.activeOnly = message.activeOnly;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ListUsersRequest>, I>>(base?: I): ListUsersRequest {
    return ListUsersRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ListUsersRequest>, I>>(object: I): ListUsersRequest {
    const message = createBaseListUsersRequest();
    message.pageSize = object.pageSize ?? 0;
    message.pageToken = object.pageToken ?? '';
    message.role = object.role ?? 0;
    message.activeOnly = object.activeOnly ?? false;
    return message;
  },
};

function createBaseListUsersResponse(): ListUsersResponse {
  return { users: [], nextPageToken: '', totalCount: 0 };
}

export const ListUsersResponse = {
  encode(message: ListUsersResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.users) {
      User.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    if (message.nextPageToken !== '') {
      writer.uint32(18).string(message.nextPageToken);
    }
    if (message.totalCount !== 0) {
      writer.uint32(24).int32(message.totalCount);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ListUsersResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListUsersResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.users.push(User.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.nextPageToken = reader.string();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.totalCount = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListUsersResponse {
    return {
      users: globalThis.Array.isArray(object?.users)
        ? object.users.map((e: any) => User.fromJSON(e))
        : [],
      nextPageToken: isSet(object.nextPageToken) ? globalThis.String(object.nextPageToken) : '',
      totalCount: isSet(object.totalCount) ? globalThis.Number(object.totalCount) : 0,
    };
  },

  toJSON(message: ListUsersResponse): unknown {
    const obj: any = {};
    if (message.users?.length) {
      obj.users = message.users.map((e) => User.toJSON(e));
    }
    if (message.nextPageToken !== '') {
      obj.nextPageToken = message.nextPageToken;
    }
    if (message.totalCount !== 0) {
      obj.totalCount = Math.round(message.totalCount);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ListUsersResponse>, I>>(base?: I): ListUsersResponse {
    return ListUsersResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ListUsersResponse>, I>>(object: I): ListUsersResponse {
    const message = createBaseListUsersResponse();
    message.users = object.users?.map((e) => User.fromPartial(e)) || [];
    message.nextPageToken = object.nextPageToken ?? '';
    message.totalCount = object.totalCount ?? 0;
    return message;
  },
};

function createBaseUpdateUserRequest(): UpdateUserRequest {
  return { id: '', user: undefined };
}

export const UpdateUserRequest = {
  encode(message: UpdateUserRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.id !== '') {
      writer.uint32(10).string(message.id);
    }
    if (message.user !== undefined) {
      User.encode(message.user, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): UpdateUserRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateUserRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.user = User.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UpdateUserRequest {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : '',
      user: isSet(object.user) ? User.fromJSON(object.user) : undefined,
    };
  },

  toJSON(message: UpdateUserRequest): unknown {
    const obj: any = {};
    if (message.id !== '') {
      obj.id = message.id;
    }
    if (message.user !== undefined) {
      obj.user = User.toJSON(message.user);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<UpdateUserRequest>, I>>(base?: I): UpdateUserRequest {
    return UpdateUserRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<UpdateUserRequest>, I>>(object: I): UpdateUserRequest {
    const message = createBaseUpdateUserRequest();
    message.id = object.id ?? '';
    message.user =
      object.user !== undefined && object.user !== null ? User.fromPartial(object.user) : undefined;
    return message;
  },
};

function createBaseUpdateUserResponse(): UpdateUserResponse {
  return { user: undefined, success: false, message: '' };
}

export const UpdateUserResponse = {
  encode(message: UpdateUserResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.user !== undefined) {
      User.encode(message.user, writer.uint32(10).fork()).ldelim();
    }
    if (message.success !== false) {
      writer.uint32(16).bool(message.success);
    }
    if (message.message !== '') {
      writer.uint32(26).string(message.message);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): UpdateUserResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateUserResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.user = User.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.success = reader.bool();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.message = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UpdateUserResponse {
    return {
      user: isSet(object.user) ? User.fromJSON(object.user) : undefined,
      success: isSet(object.success) ? globalThis.Boolean(object.success) : false,
      message: isSet(object.message) ? globalThis.String(object.message) : '',
    };
  },

  toJSON(message: UpdateUserResponse): unknown {
    const obj: any = {};
    if (message.user !== undefined) {
      obj.user = User.toJSON(message.user);
    }
    if (message.success !== false) {
      obj.success = message.success;
    }
    if (message.message !== '') {
      obj.message = message.message;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<UpdateUserResponse>, I>>(base?: I): UpdateUserResponse {
    return UpdateUserResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<UpdateUserResponse>, I>>(object: I): UpdateUserResponse {
    const message = createBaseUpdateUserResponse();
    message.user =
      object.user !== undefined && object.user !== null ? User.fromPartial(object.user) : undefined;
    message.success = object.success ?? false;
    message.message = object.message ?? '';
    return message;
  },
};

function createBaseDeleteUserRequest(): DeleteUserRequest {
  return { id: '' };
}

export const DeleteUserRequest = {
  encode(message: DeleteUserRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.id !== '') {
      writer.uint32(10).string(message.id);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): DeleteUserRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteUserRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DeleteUserRequest {
    return { id: isSet(object.id) ? globalThis.String(object.id) : '' };
  },

  toJSON(message: DeleteUserRequest): unknown {
    const obj: any = {};
    if (message.id !== '') {
      obj.id = message.id;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<DeleteUserRequest>, I>>(base?: I): DeleteUserRequest {
    return DeleteUserRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DeleteUserRequest>, I>>(object: I): DeleteUserRequest {
    const message = createBaseDeleteUserRequest();
    message.id = object.id ?? '';
    return message;
  },
};

function createBaseDeleteUserResponse(): DeleteUserResponse {
  return { success: false, message: '' };
}

export const DeleteUserResponse = {
  encode(message: DeleteUserResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.success !== false) {
      writer.uint32(8).bool(message.success);
    }
    if (message.message !== '') {
      writer.uint32(18).string(message.message);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): DeleteUserResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteUserResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.success = reader.bool();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.message = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DeleteUserResponse {
    return {
      success: isSet(object.success) ? globalThis.Boolean(object.success) : false,
      message: isSet(object.message) ? globalThis.String(object.message) : '',
    };
  },

  toJSON(message: DeleteUserResponse): unknown {
    const obj: any = {};
    if (message.success !== false) {
      obj.success = message.success;
    }
    if (message.message !== '') {
      obj.message = message.message;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<DeleteUserResponse>, I>>(base?: I): DeleteUserResponse {
    return DeleteUserResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DeleteUserResponse>, I>>(object: I): DeleteUserResponse {
    const message = createBaseDeleteUserResponse();
    message.success = object.success ?? false;
    message.message = object.message ?? '';
    return message;
  },
};

function createBaseAuthenticateUserRequest(): AuthenticateUserRequest {
  return { email: '', password: '' };
}

export const AuthenticateUserRequest = {
  encode(message: AuthenticateUserRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.email !== '') {
      writer.uint32(10).string(message.email);
    }
    if (message.password !== '') {
      writer.uint32(18).string(message.password);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): AuthenticateUserRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAuthenticateUserRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.email = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.password = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AuthenticateUserRequest {
    return {
      email: isSet(object.email) ? globalThis.String(object.email) : '',
      password: isSet(object.password) ? globalThis.String(object.password) : '',
    };
  },

  toJSON(message: AuthenticateUserRequest): unknown {
    const obj: any = {};
    if (message.email !== '') {
      obj.email = message.email;
    }
    if (message.password !== '') {
      obj.password = message.password;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AuthenticateUserRequest>, I>>(
    base?: I
  ): AuthenticateUserRequest {
    return AuthenticateUserRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AuthenticateUserRequest>, I>>(
    object: I
  ): AuthenticateUserRequest {
    const message = createBaseAuthenticateUserRequest();
    message.email = object.email ?? '';
    message.password = object.password ?? '';
    return message;
  },
};

function createBaseAuthenticateUserResponse(): AuthenticateUserResponse {
  return { user: undefined, token: '', success: false, message: '', expiresAt: undefined };
}

export const AuthenticateUserResponse = {
  encode(message: AuthenticateUserResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.user !== undefined) {
      User.encode(message.user, writer.uint32(10).fork()).ldelim();
    }
    if (message.token !== '') {
      writer.uint32(18).string(message.token);
    }
    if (message.success !== false) {
      writer.uint32(24).bool(message.success);
    }
    if (message.message !== '') {
      writer.uint32(34).string(message.message);
    }
    if (message.expiresAt !== undefined) {
      Timestamp.encode(toTimestamp(message.expiresAt), writer.uint32(42).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): AuthenticateUserResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAuthenticateUserResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.user = User.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.token = reader.string();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.success = reader.bool();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.message = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.expiresAt = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AuthenticateUserResponse {
    return {
      user: isSet(object.user) ? User.fromJSON(object.user) : undefined,
      token: isSet(object.token) ? globalThis.String(object.token) : '',
      success: isSet(object.success) ? globalThis.Boolean(object.success) : false,
      message: isSet(object.message) ? globalThis.String(object.message) : '',
      expiresAt: isSet(object.expiresAt) ? fromJsonTimestamp(object.expiresAt) : undefined,
    };
  },

  toJSON(message: AuthenticateUserResponse): unknown {
    const obj: any = {};
    if (message.user !== undefined) {
      obj.user = User.toJSON(message.user);
    }
    if (message.token !== '') {
      obj.token = message.token;
    }
    if (message.success !== false) {
      obj.success = message.success;
    }
    if (message.message !== '') {
      obj.message = message.message;
    }
    if (message.expiresAt !== undefined) {
      obj.expiresAt = message.expiresAt.toISOString();
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AuthenticateUserResponse>, I>>(
    base?: I
  ): AuthenticateUserResponse {
    return AuthenticateUserResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AuthenticateUserResponse>, I>>(
    object: I
  ): AuthenticateUserResponse {
    const message = createBaseAuthenticateUserResponse();
    message.user =
      object.user !== undefined && object.user !== null ? User.fromPartial(object.user) : undefined;
    message.token = object.token ?? '';
    message.success = object.success ?? false;
    message.message = object.message ?? '';
    message.expiresAt = object.expiresAt ?? undefined;
    return message;
  },
};

function createBaseGetUserTasksRequest(): GetUserTasksRequest {
  return { userId: '', pageSize: 0, pageToken: '' };
}

export const GetUserTasksRequest = {
  encode(message: GetUserTasksRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.userId !== '') {
      writer.uint32(10).string(message.userId);
    }
    if (message.pageSize !== 0) {
      writer.uint32(16).int32(message.pageSize);
    }
    if (message.pageToken !== '') {
      writer.uint32(26).string(message.pageToken);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GetUserTasksRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetUserTasksRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.userId = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.pageSize = reader.int32();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.pageToken = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetUserTasksRequest {
    return {
      userId: isSet(object.userId) ? globalThis.String(object.userId) : '',
      pageSize: isSet(object.pageSize) ? globalThis.Number(object.pageSize) : 0,
      pageToken: isSet(object.pageToken) ? globalThis.String(object.pageToken) : '',
    };
  },

  toJSON(message: GetUserTasksRequest): unknown {
    const obj: any = {};
    if (message.userId !== '') {
      obj.userId = message.userId;
    }
    if (message.pageSize !== 0) {
      obj.pageSize = Math.round(message.pageSize);
    }
    if (message.pageToken !== '') {
      obj.pageToken = message.pageToken;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetUserTasksRequest>, I>>(base?: I): GetUserTasksRequest {
    return GetUserTasksRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetUserTasksRequest>, I>>(
    object: I
  ): GetUserTasksRequest {
    const message = createBaseGetUserTasksRequest();
    message.userId = object.userId ?? '';
    message.pageSize = object.pageSize ?? 0;
    message.pageToken = object.pageToken ?? '';
    return message;
  },
};

function createBaseGetUserTasksResponse(): GetUserTasksResponse {
  return { tasks: [], nextPageToken: '', totalCount: 0 };
}

export const GetUserTasksResponse = {
  encode(message: GetUserTasksResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.tasks) {
      Task.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    if (message.nextPageToken !== '') {
      writer.uint32(18).string(message.nextPageToken);
    }
    if (message.totalCount !== 0) {
      writer.uint32(24).int32(message.totalCount);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GetUserTasksResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetUserTasksResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.tasks.push(Task.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.nextPageToken = reader.string();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.totalCount = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetUserTasksResponse {
    return {
      tasks: globalThis.Array.isArray(object?.tasks)
        ? object.tasks.map((e: any) => Task.fromJSON(e))
        : [],
      nextPageToken: isSet(object.nextPageToken) ? globalThis.String(object.nextPageToken) : '',
      totalCount: isSet(object.totalCount) ? globalThis.Number(object.totalCount) : 0,
    };
  },

  toJSON(message: GetUserTasksResponse): unknown {
    const obj: any = {};
    if (message.tasks?.length) {
      obj.tasks = message.tasks.map((e) => Task.toJSON(e));
    }
    if (message.nextPageToken !== '') {
      obj.nextPageToken = message.nextPageToken;
    }
    if (message.totalCount !== 0) {
      obj.totalCount = Math.round(message.totalCount);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetUserTasksResponse>, I>>(base?: I): GetUserTasksResponse {
    return GetUserTasksResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetUserTasksResponse>, I>>(
    object: I
  ): GetUserTasksResponse {
    const message = createBaseGetUserTasksResponse();
    message.tasks = object.tasks?.map((e) => Task.fromPartial(e)) || [];
    message.nextPageToken = object.nextPageToken ?? '';
    message.totalCount = object.totalCount ?? 0;
    return message;
  },
};

function createBaseUpdateUserPreferencesRequest(): UpdateUserPreferencesRequest {
  return { userId: '', preferences: undefined };
}

export const UpdateUserPreferencesRequest = {
  encode(
    message: UpdateUserPreferencesRequest,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    if (message.userId !== '') {
      writer.uint32(10).string(message.userId);
    }
    if (message.preferences !== undefined) {
      UserPreferences.encode(message.preferences, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): UpdateUserPreferencesRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateUserPreferencesRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.userId = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.preferences = UserPreferences.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UpdateUserPreferencesRequest {
    return {
      userId: isSet(object.userId) ? globalThis.String(object.userId) : '',
      preferences: isSet(object.preferences)
        ? UserPreferences.fromJSON(object.preferences)
        : undefined,
    };
  },

  toJSON(message: UpdateUserPreferencesRequest): unknown {
    const obj: any = {};
    if (message.userId !== '') {
      obj.userId = message.userId;
    }
    if (message.preferences !== undefined) {
      obj.preferences = UserPreferences.toJSON(message.preferences);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<UpdateUserPreferencesRequest>, I>>(
    base?: I
  ): UpdateUserPreferencesRequest {
    return UpdateUserPreferencesRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<UpdateUserPreferencesRequest>, I>>(
    object: I
  ): UpdateUserPreferencesRequest {
    const message = createBaseUpdateUserPreferencesRequest();
    message.userId = object.userId ?? '';
    message.preferences =
      object.preferences !== undefined && object.preferences !== null
        ? UserPreferences.fromPartial(object.preferences)
        : undefined;
    return message;
  },
};

function createBaseUpdateUserPreferencesResponse(): UpdateUserPreferencesResponse {
  return { preferences: undefined, success: false, message: '' };
}

export const UpdateUserPreferencesResponse = {
  encode(
    message: UpdateUserPreferencesResponse,
    writer: _m0.Writer = _m0.Writer.create()
  ): _m0.Writer {
    if (message.preferences !== undefined) {
      UserPreferences.encode(message.preferences, writer.uint32(10).fork()).ldelim();
    }
    if (message.success !== false) {
      writer.uint32(16).bool(message.success);
    }
    if (message.message !== '') {
      writer.uint32(26).string(message.message);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): UpdateUserPreferencesResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateUserPreferencesResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.preferences = UserPreferences.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.success = reader.bool();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.message = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UpdateUserPreferencesResponse {
    return {
      preferences: isSet(object.preferences)
        ? UserPreferences.fromJSON(object.preferences)
        : undefined,
      success: isSet(object.success) ? globalThis.Boolean(object.success) : false,
      message: isSet(object.message) ? globalThis.String(object.message) : '',
    };
  },

  toJSON(message: UpdateUserPreferencesResponse): unknown {
    const obj: any = {};
    if (message.preferences !== undefined) {
      obj.preferences = UserPreferences.toJSON(message.preferences);
    }
    if (message.success !== false) {
      obj.success = message.success;
    }
    if (message.message !== '') {
      obj.message = message.message;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<UpdateUserPreferencesResponse>, I>>(
    base?: I
  ): UpdateUserPreferencesResponse {
    return UpdateUserPreferencesResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<UpdateUserPreferencesResponse>, I>>(
    object: I
  ): UpdateUserPreferencesResponse {
    const message = createBaseUpdateUserPreferencesResponse();
    message.preferences =
      object.preferences !== undefined && object.preferences !== null
        ? UserPreferences.fromPartial(object.preferences)
        : undefined;
    message.success = object.success ?? false;
    message.message = object.message ?? '';
    return message;
  },
};

function createBaseLoginRequest(): LoginRequest {
  return { username: '', password: '' };
}

export const LoginRequest = {
  encode(message: LoginRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.username !== '') {
      writer.uint32(10).string(message.username);
    }
    if (message.password !== '') {
      writer.uint32(18).string(message.password);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): LoginRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLoginRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.username = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.password = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): LoginRequest {
    return {
      username: isSet(object.username) ? globalThis.String(object.username) : '',
      password: isSet(object.password) ? globalThis.String(object.password) : '',
    };
  },

  toJSON(message: LoginRequest): unknown {
    const obj: any = {};
    if (message.username !== '') {
      obj.username = message.username;
    }
    if (message.password !== '') {
      obj.password = message.password;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<LoginRequest>, I>>(base?: I): LoginRequest {
    return LoginRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<LoginRequest>, I>>(object: I): LoginRequest {
    const message = createBaseLoginRequest();
    message.username = object.username ?? '';
    message.password = object.password ?? '';
    return message;
  },
};

function createBaseLoginResponse(): LoginResponse {
  return { accessToken: '', refreshToken: '', user: undefined, expiresAt: undefined };
}

export const LoginResponse = {
  encode(message: LoginResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.accessToken !== '') {
      writer.uint32(10).string(message.accessToken);
    }
    if (message.refreshToken !== '') {
      writer.uint32(18).string(message.refreshToken);
    }
    if (message.user !== undefined) {
      User.encode(message.user, writer.uint32(26).fork()).ldelim();
    }
    if (message.expiresAt !== undefined) {
      Timestamp.encode(toTimestamp(message.expiresAt), writer.uint32(34).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): LoginResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLoginResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.accessToken = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.refreshToken = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.user = User.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.expiresAt = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): LoginResponse {
    return {
      accessToken: isSet(object.accessToken) ? globalThis.String(object.accessToken) : '',
      refreshToken: isSet(object.refreshToken) ? globalThis.String(object.refreshToken) : '',
      user: isSet(object.user) ? User.fromJSON(object.user) : undefined,
      expiresAt: isSet(object.expiresAt) ? fromJsonTimestamp(object.expiresAt) : undefined,
    };
  },

  toJSON(message: LoginResponse): unknown {
    const obj: any = {};
    if (message.accessToken !== '') {
      obj.accessToken = message.accessToken;
    }
    if (message.refreshToken !== '') {
      obj.refreshToken = message.refreshToken;
    }
    if (message.user !== undefined) {
      obj.user = User.toJSON(message.user);
    }
    if (message.expiresAt !== undefined) {
      obj.expiresAt = message.expiresAt.toISOString();
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<LoginResponse>, I>>(base?: I): LoginResponse {
    return LoginResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<LoginResponse>, I>>(object: I): LoginResponse {
    const message = createBaseLoginResponse();
    message.accessToken = object.accessToken ?? '';
    message.refreshToken = object.refreshToken ?? '';
    message.user =
      object.user !== undefined && object.user !== null ? User.fromPartial(object.user) : undefined;
    message.expiresAt = object.expiresAt ?? undefined;
    return message;
  },
};

function createBaseRefreshTokenRequest(): RefreshTokenRequest {
  return { refreshToken: '' };
}

export const RefreshTokenRequest = {
  encode(message: RefreshTokenRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.refreshToken !== '') {
      writer.uint32(10).string(message.refreshToken);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): RefreshTokenRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRefreshTokenRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.refreshToken = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RefreshTokenRequest {
    return {
      refreshToken: isSet(object.refreshToken) ? globalThis.String(object.refreshToken) : '',
    };
  },

  toJSON(message: RefreshTokenRequest): unknown {
    const obj: any = {};
    if (message.refreshToken !== '') {
      obj.refreshToken = message.refreshToken;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<RefreshTokenRequest>, I>>(base?: I): RefreshTokenRequest {
    return RefreshTokenRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RefreshTokenRequest>, I>>(
    object: I
  ): RefreshTokenRequest {
    const message = createBaseRefreshTokenRequest();
    message.refreshToken = object.refreshToken ?? '';
    return message;
  },
};

function createBaseRefreshTokenResponse(): RefreshTokenResponse {
  return { accessToken: '', expiresAt: undefined };
}

export const RefreshTokenResponse = {
  encode(message: RefreshTokenResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.accessToken !== '') {
      writer.uint32(10).string(message.accessToken);
    }
    if (message.expiresAt !== undefined) {
      Timestamp.encode(toTimestamp(message.expiresAt), writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): RefreshTokenResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRefreshTokenResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.accessToken = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.expiresAt = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RefreshTokenResponse {
    return {
      accessToken: isSet(object.accessToken) ? globalThis.String(object.accessToken) : '',
      expiresAt: isSet(object.expiresAt) ? fromJsonTimestamp(object.expiresAt) : undefined,
    };
  },

  toJSON(message: RefreshTokenResponse): unknown {
    const obj: any = {};
    if (message.accessToken !== '') {
      obj.accessToken = message.accessToken;
    }
    if (message.expiresAt !== undefined) {
      obj.expiresAt = message.expiresAt.toISOString();
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<RefreshTokenResponse>, I>>(base?: I): RefreshTokenResponse {
    return RefreshTokenResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RefreshTokenResponse>, I>>(
    object: I
  ): RefreshTokenResponse {
    const message = createBaseRefreshTokenResponse();
    message.accessToken = object.accessToken ?? '';
    message.expiresAt = object.expiresAt ?? undefined;
    return message;
  },
};

function createBaseLogoutRequest(): LogoutRequest {
  return { accessToken: '' };
}

export const LogoutRequest = {
  encode(message: LogoutRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.accessToken !== '') {
      writer.uint32(10).string(message.accessToken);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): LogoutRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLogoutRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.accessToken = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): LogoutRequest {
    return { accessToken: isSet(object.accessToken) ? globalThis.String(object.accessToken) : '' };
  },

  toJSON(message: LogoutRequest): unknown {
    const obj: any = {};
    if (message.accessToken !== '') {
      obj.accessToken = message.accessToken;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<LogoutRequest>, I>>(base?: I): LogoutRequest {
    return LogoutRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<LogoutRequest>, I>>(object: I): LogoutRequest {
    const message = createBaseLogoutRequest();
    message.accessToken = object.accessToken ?? '';
    return message;
  },
};

function createBaseHealthResponse(): HealthResponse {
  return { healthy: false, version: '', timestamp: undefined };
}

export const HealthResponse = {
  encode(message: HealthResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.healthy !== false) {
      writer.uint32(8).bool(message.healthy);
    }
    if (message.version !== '') {
      writer.uint32(18).string(message.version);
    }
    if (message.timestamp !== undefined) {
      Timestamp.encode(toTimestamp(message.timestamp), writer.uint32(26).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): HealthResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseHealthResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.healthy = reader.bool();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.version = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.timestamp = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): HealthResponse {
    return {
      healthy: isSet(object.healthy) ? globalThis.Boolean(object.healthy) : false,
      version: isSet(object.version) ? globalThis.String(object.version) : '',
      timestamp: isSet(object.timestamp) ? fromJsonTimestamp(object.timestamp) : undefined,
    };
  },

  toJSON(message: HealthResponse): unknown {
    const obj: any = {};
    if (message.healthy !== false) {
      obj.healthy = message.healthy;
    }
    if (message.version !== '') {
      obj.version = message.version;
    }
    if (message.timestamp !== undefined) {
      obj.timestamp = message.timestamp.toISOString();
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<HealthResponse>, I>>(base?: I): HealthResponse {
    return HealthResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<HealthResponse>, I>>(object: I): HealthResponse {
    const message = createBaseHealthResponse();
    message.healthy = object.healthy ?? false;
    message.version = object.version ?? '';
    message.timestamp = object.timestamp ?? undefined;
    return message;
  },
};

/** Standard CRUD operations */
export interface TaskService {
  CreateTask(request: CreateTaskRequest): Promise<CreateTaskResponse>;
  GetTask(request: GetTaskRequest): Promise<GetTaskResponse>;
  UpdateTask(request: UpdateTaskRequest): Promise<UpdateTaskResponse>;
  DeleteTask(request: DeleteTaskRequest): Promise<DeleteTaskResponse>;
  ListTasks(request: ListTasksRequest): Promise<ListTasksResponse>;
  SearchTasks(request: SearchTasksRequest): Promise<SearchTasksResponse>;
  BulkUpdateTasks(request: BulkUpdateTasksRequest): Promise<BulkUpdateTasksResponse>;
  StreamTaskEvents(request: StreamTaskEventsRequest): Observable<TaskEvent>;
  ImportTasks(request: Observable<CreateTaskRequest>): Observable<CreateTaskResponse>;
  CollaborateOnTasks(request: Observable<TaskEvent>): Observable<TaskEvent>;
  UploadTaskAttachment(
    request: Observable<UploadTaskAttachmentRequest>
  ): Promise<UploadTaskAttachmentResponse>;
  GetTaskAnalytics(request: GetTaskAnalyticsRequest): Promise<GetTaskAnalyticsResponse>;
  Health(request: Empty): Promise<HealthResponse>;
}

export const TaskServiceServiceName = 'example.TaskService';
export class TaskServiceClientImpl implements TaskService {
  private readonly rpc: Rpc;
  private readonly service: string;
  constructor(rpc: Rpc, opts?: { service?: string }) {
    this.service = opts?.service || TaskServiceServiceName;
    this.rpc = rpc;
    this.CreateTask = this.CreateTask.bind(this);
    this.GetTask = this.GetTask.bind(this);
    this.UpdateTask = this.UpdateTask.bind(this);
    this.DeleteTask = this.DeleteTask.bind(this);
    this.ListTasks = this.ListTasks.bind(this);
    this.SearchTasks = this.SearchTasks.bind(this);
    this.BulkUpdateTasks = this.BulkUpdateTasks.bind(this);
    this.StreamTaskEvents = this.StreamTaskEvents.bind(this);
    this.ImportTasks = this.ImportTasks.bind(this);
    this.CollaborateOnTasks = this.CollaborateOnTasks.bind(this);
    this.UploadTaskAttachment = this.UploadTaskAttachment.bind(this);
    this.GetTaskAnalytics = this.GetTaskAnalytics.bind(this);
    this.Health = this.Health.bind(this);
  }
  CreateTask(request: CreateTaskRequest): Promise<CreateTaskResponse> {
    const data = CreateTaskRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, 'CreateTask', data);
    return promise.then((data) => CreateTaskResponse.decode(_m0.Reader.create(data)));
  }

  GetTask(request: GetTaskRequest): Promise<GetTaskResponse> {
    const data = GetTaskRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, 'GetTask', data);
    return promise.then((data) => GetTaskResponse.decode(_m0.Reader.create(data)));
  }

  UpdateTask(request: UpdateTaskRequest): Promise<UpdateTaskResponse> {
    const data = UpdateTaskRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, 'UpdateTask', data);
    return promise.then((data) => UpdateTaskResponse.decode(_m0.Reader.create(data)));
  }

  DeleteTask(request: DeleteTaskRequest): Promise<DeleteTaskResponse> {
    const data = DeleteTaskRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, 'DeleteTask', data);
    return promise.then((data) => DeleteTaskResponse.decode(_m0.Reader.create(data)));
  }

  ListTasks(request: ListTasksRequest): Promise<ListTasksResponse> {
    const data = ListTasksRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, 'ListTasks', data);
    return promise.then((data) => ListTasksResponse.decode(_m0.Reader.create(data)));
  }

  SearchTasks(request: SearchTasksRequest): Promise<SearchTasksResponse> {
    const data = SearchTasksRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, 'SearchTasks', data);
    return promise.then((data) => SearchTasksResponse.decode(_m0.Reader.create(data)));
  }

  BulkUpdateTasks(request: BulkUpdateTasksRequest): Promise<BulkUpdateTasksResponse> {
    const data = BulkUpdateTasksRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, 'BulkUpdateTasks', data);
    return promise.then((data) => BulkUpdateTasksResponse.decode(_m0.Reader.create(data)));
  }

  StreamTaskEvents(request: StreamTaskEventsRequest): Observable<TaskEvent> {
    const data = StreamTaskEventsRequest.encode(request).finish();
    const result = this.rpc.serverStreamingRequest(this.service, 'StreamTaskEvents', data);
    return result.pipe(map((data) => TaskEvent.decode(_m0.Reader.create(data))));
  }

  ImportTasks(request: Observable<CreateTaskRequest>): Observable<CreateTaskResponse> {
    const data = request.pipe(map((request) => CreateTaskRequest.encode(request).finish()));
    const result = this.rpc.bidirectionalStreamingRequest(this.service, 'ImportTasks', data);
    return result.pipe(map((data) => CreateTaskResponse.decode(_m0.Reader.create(data))));
  }

  CollaborateOnTasks(request: Observable<TaskEvent>): Observable<TaskEvent> {
    const data = request.pipe(map((request) => TaskEvent.encode(request).finish()));
    const result = this.rpc.bidirectionalStreamingRequest(this.service, 'CollaborateOnTasks', data);
    return result.pipe(map((data) => TaskEvent.decode(_m0.Reader.create(data))));
  }

  UploadTaskAttachment(
    request: Observable<UploadTaskAttachmentRequest>
  ): Promise<UploadTaskAttachmentResponse> {
    const data = request.pipe(
      map((request) => UploadTaskAttachmentRequest.encode(request).finish())
    );
    const promise = this.rpc.clientStreamingRequest(this.service, 'UploadTaskAttachment', data);
    return promise.then((data) => UploadTaskAttachmentResponse.decode(_m0.Reader.create(data)));
  }

  GetTaskAnalytics(request: GetTaskAnalyticsRequest): Promise<GetTaskAnalyticsResponse> {
    const data = GetTaskAnalyticsRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, 'GetTaskAnalytics', data);
    return promise.then((data) => GetTaskAnalyticsResponse.decode(_m0.Reader.create(data)));
  }

  Health(request: Empty): Promise<HealthResponse> {
    const data = Empty.encode(request).finish();
    const promise = this.rpc.request(this.service, 'Health', data);
    return promise.then((data) => HealthResponse.decode(_m0.Reader.create(data)));
  }
}

export interface UserService {
  CreateUser(request: CreateUserRequest): Promise<CreateUserResponse>;
  GetUser(request: GetUserRequest): Promise<GetUserResponse>;
  ListUsers(request: ListUsersRequest): Promise<ListUsersResponse>;
  UpdateUser(request: UpdateUserRequest): Promise<UpdateUserResponse>;
  DeleteUser(request: DeleteUserRequest): Promise<DeleteUserResponse>;
  Login(request: LoginRequest): Promise<LoginResponse>;
  RefreshToken(request: RefreshTokenRequest): Promise<RefreshTokenResponse>;
  Logout(request: LogoutRequest): Promise<Empty>;
  AuthenticateUser(request: AuthenticateUserRequest): Promise<AuthenticateUserResponse>;
  GetUserTasks(request: GetUserTasksRequest): Promise<GetUserTasksResponse>;
  UpdateUserPreferences(
    request: UpdateUserPreferencesRequest
  ): Promise<UpdateUserPreferencesResponse>;
}

export const UserServiceServiceName = 'example.UserService';
export class UserServiceClientImpl implements UserService {
  private readonly rpc: Rpc;
  private readonly service: string;
  constructor(rpc: Rpc, opts?: { service?: string }) {
    this.service = opts?.service || UserServiceServiceName;
    this.rpc = rpc;
    this.CreateUser = this.CreateUser.bind(this);
    this.GetUser = this.GetUser.bind(this);
    this.ListUsers = this.ListUsers.bind(this);
    this.UpdateUser = this.UpdateUser.bind(this);
    this.DeleteUser = this.DeleteUser.bind(this);
    this.Login = this.Login.bind(this);
    this.RefreshToken = this.RefreshToken.bind(this);
    this.Logout = this.Logout.bind(this);
    this.AuthenticateUser = this.AuthenticateUser.bind(this);
    this.GetUserTasks = this.GetUserTasks.bind(this);
    this.UpdateUserPreferences = this.UpdateUserPreferences.bind(this);
  }
  CreateUser(request: CreateUserRequest): Promise<CreateUserResponse> {
    const data = CreateUserRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, 'CreateUser', data);
    return promise.then((data) => CreateUserResponse.decode(_m0.Reader.create(data)));
  }

  GetUser(request: GetUserRequest): Promise<GetUserResponse> {
    const data = GetUserRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, 'GetUser', data);
    return promise.then((data) => GetUserResponse.decode(_m0.Reader.create(data)));
  }

  ListUsers(request: ListUsersRequest): Promise<ListUsersResponse> {
    const data = ListUsersRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, 'ListUsers', data);
    return promise.then((data) => ListUsersResponse.decode(_m0.Reader.create(data)));
  }

  UpdateUser(request: UpdateUserRequest): Promise<UpdateUserResponse> {
    const data = UpdateUserRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, 'UpdateUser', data);
    return promise.then((data) => UpdateUserResponse.decode(_m0.Reader.create(data)));
  }

  DeleteUser(request: DeleteUserRequest): Promise<DeleteUserResponse> {
    const data = DeleteUserRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, 'DeleteUser', data);
    return promise.then((data) => DeleteUserResponse.decode(_m0.Reader.create(data)));
  }

  Login(request: LoginRequest): Promise<LoginResponse> {
    const data = LoginRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, 'Login', data);
    return promise.then((data) => LoginResponse.decode(_m0.Reader.create(data)));
  }

  RefreshToken(request: RefreshTokenRequest): Promise<RefreshTokenResponse> {
    const data = RefreshTokenRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, 'RefreshToken', data);
    return promise.then((data) => RefreshTokenResponse.decode(_m0.Reader.create(data)));
  }

  Logout(request: LogoutRequest): Promise<Empty> {
    const data = LogoutRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, 'Logout', data);
    return promise.then((data) => Empty.decode(_m0.Reader.create(data)));
  }

  AuthenticateUser(request: AuthenticateUserRequest): Promise<AuthenticateUserResponse> {
    const data = AuthenticateUserRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, 'AuthenticateUser', data);
    return promise.then((data) => AuthenticateUserResponse.decode(_m0.Reader.create(data)));
  }

  GetUserTasks(request: GetUserTasksRequest): Promise<GetUserTasksResponse> {
    const data = GetUserTasksRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, 'GetUserTasks', data);
    return promise.then((data) => GetUserTasksResponse.decode(_m0.Reader.create(data)));
  }

  UpdateUserPreferences(
    request: UpdateUserPreferencesRequest
  ): Promise<UpdateUserPreferencesResponse> {
    const data = UpdateUserPreferencesRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, 'UpdateUserPreferences', data);
    return promise.then((data) => UpdateUserPreferencesResponse.decode(_m0.Reader.create(data)));
  }
}

interface Rpc {
  request(service: string, method: string, data: Uint8Array): Promise<Uint8Array>;
  clientStreamingRequest(
    service: string,
    method: string,
    data: Observable<Uint8Array>
  ): Promise<Uint8Array>;
  serverStreamingRequest(service: string, method: string, data: Uint8Array): Observable<Uint8Array>;
  bidirectionalStreamingRequest(
    service: string,
    method: string,
    data: Observable<Uint8Array>
  ): Observable<Uint8Array>;
}

function bytesFromBase64(b64: string): Uint8Array {
  if ((globalThis as any).Buffer) {
    return Uint8Array.from(globalThis.Buffer.from(b64, 'base64'));
  } else {
    const bin = globalThis.atob(b64);
    const arr = new Uint8Array(bin.length);
    for (let i = 0; i < bin.length; ++i) {
      arr[i] = bin.charCodeAt(i);
    }
    return arr;
  }
}

function base64FromBytes(arr: Uint8Array): string {
  if ((globalThis as any).Buffer) {
    return globalThis.Buffer.from(arr).toString('base64');
  } else {
    const bin: string[] = [];
    arr.forEach((byte) => {
      bin.push(globalThis.String.fromCharCode(byte));
    });
    return globalThis.btoa(bin.join(''));
  }
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin
  ? T
  : T extends globalThis.Array<infer U>
    ? globalThis.Array<DeepPartial<U>>
    : T extends ReadonlyArray<infer U>
      ? ReadonlyArray<DeepPartial<U>>
      : T extends {}
        ? { [K in keyof T]?: DeepPartial<T[K]> }
        : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin
  ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };

function toTimestamp(date: Date): Timestamp {
  const seconds = Math.trunc(date.getTime() / 1_000);
  const nanos = (date.getTime() % 1_000) * 1_000_000;
  return { seconds, nanos };
}

function fromTimestamp(t: Timestamp): Date {
  let millis = (t.seconds || 0) * 1_000;
  millis += (t.nanos || 0) / 1_000_000;
  return new globalThis.Date(millis);
}

function fromJsonTimestamp(o: any): Date {
  if (o instanceof globalThis.Date) {
    return o;
  } else if (typeof o === 'string') {
    return new globalThis.Date(o);
  } else {
    return fromTimestamp(Timestamp.fromJSON(o));
  }
}

function longToNumber(long: Long): number {
  if (long.gt(globalThis.Number.MAX_SAFE_INTEGER)) {
    throw new globalThis.Error('Value is larger than Number.MAX_SAFE_INTEGER');
  }
  if (long.lt(globalThis.Number.MIN_SAFE_INTEGER)) {
    throw new globalThis.Error('Value is smaller than Number.MIN_SAFE_INTEGER');
  }
  return long.toNumber();
}

if (_m0.util.Long !== Long) {
  _m0.util.Long = Long as any;
  _m0.configure();
}

function isObject(value: any): boolean {
  return typeof value === 'object' && value !== null;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}
